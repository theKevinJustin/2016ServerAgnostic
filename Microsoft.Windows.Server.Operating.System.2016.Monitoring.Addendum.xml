<?xml version="1.0" encoding="utf-8"?><ManagementPack ContentReadable="true" SchemaVersion="2.0" OriginalSchemaVersion="1.1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <Manifest>
    <Identity>
      <ID>Microsoft.Windows.Server.Operating.System.2016.Monitoring.Addendum</ID>
      <Version>1.0.5.9</Version>
    </Identity>
    <Name>Microsoft Windows Server Operating System 2016 Monitoring Addendum</Name>
    <References>
      <Reference Alias="Windows">
        <ID>Microsoft.Windows.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWSL">
        <ID>Microsoft.Windows.Server.Library</ID>
        <Version>10.0.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="System">
        <ID>System.Library</ID>
        <Version>7.5.8501.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWS6D">
        <ID>Microsoft.Windows.Server.2016.Discovery</ID>
        <Version>10.0.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="SC">
        <ID>Microsoft.SystemCenter.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="MWS6M">
        <ID>Microsoft.Windows.Server.2016.Monitoring</ID>
        <Version>10.0.0.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
      <Reference Alias="Health">
        <ID>System.Health.Library</ID>
        <Version>7.0.8433.0</Version>
        <PublicKeyToken>31bf3856ad364e35</PublicKeyToken>
      </Reference>
    </References>
  </Manifest>
  <TypeDefinitions>
    <ModuleTypes>
      <DataSourceModuleType ID="Proactive.DailyTasks.WINOSAlerts.Close.Script.DataSource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>06:10</Start>
                        <End>06:30</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.DailyTasks.WINOSAlerts.2016.Close.Script.Datasource.v1059.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather WINOS 2016+ alerts and close via on demand task
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.WINOSAlerts.2016.Close.Script.Datasource.v1059.ps1"
$EventID = "580"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-7)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}
	
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather WINOS 2016+ Alerts for date ($date).")


# Gather WINOS alerts
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
$SCOMCoreMP = Get-SCOMManagementPack -DisplayName "Windows Server 2016 and above Operating Systems (Monitoring)"
$SCOMCoreRules = $SCOMCoreMP.GetRules()
$SCOMCoreMonitors = $SCOMCoreMP.GetMonitors()

$SCOMCoreReportAlerts = Get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMCoreReportAlerts.Count

$SCOMCoreRuleAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -in $SCOMCoreRules.DisplayName) }
$SCOMCoreRuleAlerts.Count

$SCOMCoreMonitorAlerts = $SCOMCoreReportAlerts | ? { ($_.Name -in $SCOMCoreMonitors.DisplayName ) }
$SCOMCoreMonitorAlerts.Count

# Open/Closed breakout
$OpenADDSAlerts = $SCOMCoreReportAlerts
$OpenADDSAlerts.Count
$ClosedADDSAlerts = Get-SCOMAlert -ResolutionState 255 | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$ClosedADDSAlerts.Count


#$Test = $ADFSAlerts.Count
$Test = $SCOMCoreMonitorAlerts.Count


#
# Build report
$WINOSAMessage = @()


if ( $SCOMCoreReportAlerts.count -eq 0 )
	{
	$Message = "ZERO WINOS 2016+ Monitors auto-closed for ($date)"
	$WINOSAMessage += "ZERO WINOS 2016+ Monitors auto-closed for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}


if ( $SCOMCoreReportAlerts.count -gt 0 )
	{
	$WINOSAMessage += ""
	$WINOSAMessage += "Alert Count = $Test "
	$WINOSAMessage += ""
	$WINOSAMessage += "# WINOS 2016+ Monitors auto-closed"
	$WINOSAMessage += "#=========================================================="
	$WINOSAMessage += "# Number of open WINOS 2016+ alerts = $($SCOMCoreReportAlerts.Count)"
	$WINOSAMessage += "#=========================================================="
	$WINOSAMessage += ""
	$WINOSAMessage += "#==============================================="
	$WINOSAMessage += "# Monitors AND Rules that were auto closed = $($SCOMCoreReportAlerts.Count)"
	$WINOSAMessage += "#==============================================="
	$WINOSAMessage += ""
	#$WINOSAMessage += "#=============="
	#$WINOSAMessage += "# Alert details"
	#$WINOSAMessage += "#=============="
	#$WINOSAMessage += $SCOMCoreReportAlerts
	#$WINOSAMessage += ""
	#$WINOSAMessage += "#================================================"
	#$WINOSAMessage += "# List of included Monitor/Rule names auto-closed"
	#$WINOSAMessage += "#================================================"
	#$WINOSAMessage += "# Monitors"
	#$WINOSAMessage += $SCOMCoreMonitorAlerts
	#$WINOSAMessage += "# Rules"
	#$WINOSAMessage += $SCOMCoreRuleAlerts
	#$WINOSAMessage += "#============================================================"
	#$WINOSAMessage += ""

	$WINOSAMessage
	$WINOSAMessage = $WINOSAMessage | out-string
	}

#============================================================

$Result = "GOOD"
$Message = "WINOS Monitors auto-closed for ($date)"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Report completed for ($date). `n `n$WINOSAMessage")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$WINOSAMessage)


# Return all bags
$bag
#=================================================================================


# Rule closure logic
#=================================================================================
$SCOMCoreRulesToClear = $SCOMCoreRuleAlerts | where { ( $_.TimeAdded -lt $Age ) }
# Convert Age back to days for alert properties logging
$Days = ((Get-date) - $Age).Days
if ( $SCOMCoreRulesToClear.Count -gt 0 )
	{
	$SCOMCoreRulesToClear | Resolve-SCOMAlert -Comment "Closing $Days day old alerts after report alert generated - ADDS Addendum Automation DS"
	}

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS rule reset completed for ($date)")

#=================================================================================
# Reset Monitors Script base code modified
# Put ps1 in mgmtpacks folder
# https://sc.scomurr.com/scom-2012-monitor-reset-cleaning-up-the-environment/
#	Download
# https://gallery.technet.microsoft.com/SCOM-2012-Batch-reset-63a17534
	
#Alternate
#https://gallery.technet.microsoft.com/scriptcenter/Auto-reset-script-for-d8b775ca

# Changed up logic to sort unique classes in mgmnt pack families.
# Added Age variable for monitors thanks to Aris Somatis - $Age specified in top level variables
# Cycling through monitors made reset loop huge ~650 monitors when only ~50 classes
# New logic reduced runtime from 8 minutes to roughly 8 seconds
#=================================================================================

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Monitor Reset automation started for ($date).")


if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	# Get classes - Examples: Microsoft.Windows.Server.AD.2016.Discovery, Microsoft.Windows.Server.AD.Library
		$Library = Get-SCOMManagementPack -name "Microsoft.Windows.Server.Library"
		$Monitoring = $SCOMCoreMP
		$Discovery = Get-SCOMManagementPack -name Microsoft.Windows.Server.2016.Discovery

	# pack naming
	$OSClasses = @(Get-SCOMClass -ManagementPack $Library; Get-SCOMClass -ManagementPack $Discovery; )
	$OSClass = $OSClasses | sort -property Name -uniq
	# Debug
	$OSClass.Count

	# Set up monitor objects to reset
	foreach ($Class in $OSClass)
		{
		$ActiveMonitors = @(Get-SCOMClassInstance -Class $Class | ? { ($_.healthstate -ne 'Success') -AND ( $_.healthstate -ne 'Uninitialized') -AND ($_.IsAvailable -eq $true) } )
		# Debug
		$ActiveMonitors.Count
		# $ActiveMonitors | fl -property *
		write-host "Found" $ActiveMonitors.Count "unhealthy monitors for class" $Class
		foreach ( $UnhealthyOLDMonitor in $ActiveMonitors )
			{
			#if ( $UnhealthyOLDMonitor.AvailabilityLastModified -lt $Age )
			if ( $UnhealthyOLDMonitor.StateLastModified -lt $Age )
				{
				#$UnhealthyMonitors += $ActiveMonitors.Count
				#UnhealthyOLDMonitor | select AvailabilityLastModified,Path,DisplayName
				#$UnhealthyOLDMonitor.Count
				#write-host "Found" + $UnhealthyOLDMonitor.Count + "unhealthy monitor beyond" $Age "days."
				#write-host ""
				if ( $ActiveMonitors.Count -gt 0)
					{
					foreach ( $ActiveMonitor in $UnhealthyOLDMonitor )
						{
						# Debug
						$ActiveMonitor.ID
						write-host " Resetting Health State on '" + $ActiveMonitor.FullName + "'" 
						write-host ""
						$ActiveMonitor.ResetMonitoringState($ActiveMonitor)
						}
					}
				}
			}
		}
	# Debug
	#$MonitorClass | fl -property *
	#$MonitorClass | select DisplayName,ID
	}


# Debug Write event for rule closure
#=================================================================================
# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS monitor reset completed for ($date)")

#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.Microsoft.Windows.BaseEventProvider" Accessibility="Public" Batching="false">
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>Windows!Microsoft.Windows.ComputerNameSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="ComputerName" type="ComputerNameType" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="LogName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="AllowProxying" type="xsd:boolean" minOccurs="0" maxOccurs="1" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <ModuleImplementation Isolation="Any">
          <Native>
            <ClassID>B98BD20C-3CC8-4AFE-9F68-5702C74D73DB</ClassID>
          </Native>
        </ModuleImplementation>
        <OutputType>Windows!Microsoft.Windows.EventData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Monitor.Datasource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:string" name="DriveLetter" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="DriveLetter" Selector="$Config/DriveLetter$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>10:42</Start>
                        <End>11:02</End>
                        <DaysOfWeekMask>1</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Monitor.Datasource.v1059.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Proactive logical disk cleanup
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================
# param([string]$DriveLetter #,[string]$ComputerName)
param([string]$DriveLetter)


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ComputerName = "computername.domain.com"
$ComputerName = $env:ComputerName
#$DriveLetter = "C"
$DriveLetter
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
$ScriptName = "Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Monitor.Datasource.v1059.ps1"
$EventID = "680"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
# Load PropertyBag function 
$bag = $momapi.CreatePropertyBag()

#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# Begin MAIN script section
#=================================================================================
#Log script parameters we received
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script parameters passed into datasource: `nDriveLetter: ($DriveLetter). `nComputerName: ($ComputerName).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive Disk Cleanup Alert report for date ($date).")

$DSMessage = "Proactive Logical Disk Cleanup Alert for date ($date)."


# Check Disk free space
#=====================
if ($Driveletter -eq "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -eq "C:" }
	$CFreeSpace.DeviceID
	$CFreeSpace

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace

	$SoftwareDistribution = (gci C:\windows\SoftwareDistribution | measure length -s).sum / 1Mb
	# Debug
	$SoftwareDistribution

	# Check for large profile sizes
	#==================================
	$Profiles = Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") -and ($_.localpath -notlike "C:\WINDOWS*"))}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }
	#$Profiles=Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") )}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }

	# Figure out C:\Users directory size
	$CUsersTableObject = @()

	#$OS = [Environment]::OSVersion
	$PSVersionTable.PSVersion.Major

	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$User = (gci $DriveLetter\users -Recurse -Depth 1 -EA 4 | measure length -s).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$User = (gci $DriveLetter\users -Recurse | measure length -s).sum
		}

	$UserSize = [math]::Round($User/1GB,2) 
	$CUsersTableObject += "$($UserSize) = Size of C:\Users directory"
	$CUsersTableObject += ""
	$CUsersTableObject

	$ProfileTableObject = @()

	# Loop through profiles
	foreach ($Profile in $Profiles)
		{
		$Profile
		#$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse | measure length -s).sum
			}

		$ProfileTableObject += [pscustomobject]@{	
		SizeGB = [math]::Round($Size/1GB,2)
		#AccountID = $Profile
		UserDirectory = "$Profile"
	      }
		}
	$ProfileTableObject | sort -property SizeGB -desc

	# Cleanup C:\Windows\Temp
	#=====================
	# May see access denied errors - Get-ChildItem
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse -Depth 1 -EA 4 | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse | Measure-Object -Property Length -Sum ).sum
		}
	}


# Non C Drive cleanup
#=============================
# Debug $Driveletter
#$Driveletter = "D"
#$Driveletter
if ($DriveLetter -ne "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

	$DeviceDriveLetter;	cd \
    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace
	}


# Check disk space (default C:)
#======================================= 
# Debug
$DriveLetter
#
If ($DiskFreeSpace.FreeSpace -gt 5 )
	{
	$strCondition = "Good"
	#$DSMessage = "NO ($DriveLetter) drive Cleanup required for date ($date)."
	$end
	}
 
If ($DiskFreeSpace.FreeSpace -lt 5 )
	{
	#$DriveLetter = "C:"
	#Set the condition = bad.  This represents your script finding something wrong
	$strCondition = "Bad"

	# Proactive C: drive Cleanup
	$resman= New-Object -ComObject "UIResource.UIResourceMgr"
	$cacheInfo=$resman.GetCacheInfo()
	$cacheinfo.GetCacheElements()  | foreach {$cacheInfo.DeleteCacheElement($_.CacheElementID)}


	# get-volume
	#=====================
	# $DriveLetter = "C"
	$ExpandC = get-volume
	$ExpandAction = $ExpandC | ? { ( $_.SizeRemaining -gt "0" ) -AND ( $_.Driveletter -eq "$DriveLetter" ) }

	if ( $ExpandAction.DriveLetter -eq $true)
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Expand drive via Disk Manager on ($ComputerName)")
		}


	# Check Disk free space AFTER cleanup
	#==================================
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

	$DiskFreeSpace = [pscustomobject]@{
		DeviceID = $CFreeSpace.DeviceID
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
        }

	$DiskFreeSpace

	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter
 
	# Check C Drive folder size
	#==========================
	#$CheckCDriveFolders = (gci C:).Name | ? { ( $_ -ne "Users" ) -AND ( $_ -ne "Windows" )  }
	$CheckCDriveFolders = (gci $DeviceDriveLetter -directory).Name | ? { ( $_ -ne "Users" ) }
	$CheckCDriveFolders

	$Cfolders = @()

	Foreach ( $folder in $CheckCDriveFolders )
		{
		#$folder
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse -Depth 1 -EA SilentlyContinue | Measure-Object -Property Length -Sum ).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse | Measure-Object -Property Length -Sum ).sum
			}
		$Size

		$CFolders += [pscustomobject]@{
			Directory = $folder
			SizeGB = [math]::Round($Size/1GB,2)
			}
		}
	$Cfolders  #| sort -property SizeGB -desc


# Second attempt will clean up software distribution
#==================================
If ($DiskFreeSpace.FreeSpace -lt 15 )
	{
	# Audit Software Distribution
	#==================================
	If ( $SoftwareDistribution -lt "3000" )
		{
		Write-host "NO SME/SystemOwner/SysAdmin/Server Action required"
		}

	If ( $SoftwareDistribution -gt "3000" )
		{
		Write-host "SME/SystemOwner/SysAdmin/Server Action required, stopping Windows Update service, removing SoftwareDIstribution folder and restarting"
		Get-Service -Name wuauserv | Stop-Service 
		Remove-Item -Path C:\Windows\SoftwareDistribution -Recurse 
		Get-Service -Name wuauserv | Start-Service
		Write-host "Windows Update wuauserv service restarted after SoftwareDistribution directory removed"
		}

	# Cleanup IIS log files
	#=====================
	#if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC1 )
	#	{
	#	# Years older than 
	#	$HowOld = [DateTime]::Now.AddYears(-1)
	#	$RecentUse = [DateTime]::Now.AddDays(-90)
	#	# Path to root folder 
	#	$Path = "C:\inetpub\logs\LogFiles\W3SVC1\*.log" 
	#	# Deletion task 
	#	get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#	}

	#if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC2 )
	#	{
	#	# Years older than 
	#	$HowOld = [DateTime]::Now.AddYears(-1)
	#	$RecentUse = [DateTime]::Now.AddDays(-90)
	#	# Path to root folder 
	#	$Path = "C:\inetpub\logs\LogFiles\W3SVC2\*.log"
	#	# Deletion task 
	#	get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#	}

	# D drive Event cleanup
	#$DeviceDriveLetter
	#If ( $DeviceDriveLetter -eq "D:" )
	#	{
	#	If ( Test-Path "D:\Domain Event Logs\Domain Controllers" )
	#		{
	#		# Years older than 
	#		$HowOld = [DateTime]::Now.AddYears(-2)
	#		$RecentUse = [DateTime]::Now.AddDays(-7) 
	#		# Path to root folder 
	#		$Path = "D:\Domain Event Logs\Domain Controllers\*.evt"
	#		# Deletion task
	#		get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}
		
		# Cleanup IIS log files
		#=====================
	#	if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC1 )
	#		{
	#		# Years older than
	#		$HowOld = [DateTime]::Now.AddYears(-1)
	#		$RecentUse = [DateTime]::Now.AddDays(-90)
	#		# Path to root folder
	#		$Path = "D:\inetpub\logs\LogFiles\W3SVC1\*.log"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC2 )
	#		{
	#		# Years older than
	#		$HowOld = [DateTime]::Now.AddYears(-1)
	#		$RecentUse = [DateTime]::Now.AddDays(-90)
	#		# Path to root folder
	#		$Path = "D:\inetpub\logs\LogFiles\W3SVC2\*.log"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}
	#	}

		# Example for VEEAM backup files
		#================================
	#	If ( Test-Path "D:\Backup" )
	#		{
	#		# Years older than
    #       $HowOld = [DateTime]::Now.AddYears(-2)
    #       $RecentUse = [DateTime]::Now.AddDays(-8)
	#		# Path to root folder
    #       $Path = "D:\Backup\*.v*"
	#		# Deletion task
	#		get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld `
	#			-and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

		# Cleanup SQL Backup files
		#=====================
		# Example paths
		# G:\Backup
		# S:\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\Backup

	#	if ( Test-Path "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup" )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path "G:\Backup )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "G:\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	# Check folder size after cleanup
	#==========================
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
		}

	$After = [math]::Round($AfterSize/1GB,2)
	}


	# Summary Report
	#==================================
	$ProfileTableOutput = $ProfileTableObject | sort -property SizeGB -desc | out-string
	$CFolderOutput = $Cfolders | sort -property SizeGB -desc | out-string
	$Computer = $ENV:ComputerName

	$CdriveCleanupReport = @()
 
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += $DSMessage
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "# Server Drive audit on server $($Computer)"
	$CdriveCleanupReport += "# Server Drive = $($DriveLetter)"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "Before totals = $($Before) to after total = $($After)"
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "# Software Distribution folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $SoftwareDistribution | out-string
	$CdriveCleanupReport += ""

if ($Driveletter -eq "C" )
	{
	$CdriveCleanupReport += "# Audit of profiles for cleanup"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $ProfileTableOutput | out-string
	$CdriveCleanupReport += ""
	}

	$CdriveCleanupReport += "# Audit of folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $CFolderOutput | out-string
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "NOTE: Manual effort required:"
	$CdriveCleanupReport += "SME/SystemOwner/SysAdmin/Server SME required to clean up drive folders"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += ""
	}

# Verify output
$CdriveCleanupReport = $CdriveCleanupReport | out-string
$CdriveCleanupReport


#Check the value of $strCondition
IF ($strCondition -eq "Good")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"NO SME/SystemOwner/SysAdmin/Server action required")
	$bag.AddValue('Result',$strCondition)
	}
IF ($strCondition -eq "Bad")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$CdriveCleanupReport")
	$bag.AddValue('Result',$strCondition)
	$bag.AddValue('Summary',$CdriveCleanupReport)
	}

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Cleanup Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <Parameters>
                  <Parameter>
                    <Name>DriveLetter</Name>
                    <Value>$Config/DriveLetter$</Value>
                  </Parameter>
                </Parameters>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.DailyTasks.GroupPolicy.2016.Report.Script.DataSource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>05:11</Start>
                        <End>05:31</End>
                        <DaysOfWeekMask>62</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
                <ScriptName>Proactive.DailyTasks.GroupPolicy.2016.Report.Script.Alert.DataSource.v1059.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather GroupPolicyReport alerts and close via on demand task
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.GroupPolicy.2016.Report.Script.Alert.DataSource.v1059.ps1"
$EventID = "552"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Group Policy update failed alerts for date ($date).")
  $Message = "Group Policy Update Failed Daily Report for ($date)"
  

# Gather Group Policy update failed alerts
# Monitors then rules
$GroupPolicyAlerts = get-scomalert -name "*Group Policy*" | ? { ( $_.TimeRaised -ge $Time ) }

#| ? { ( $_.Name -eq "The Group Policy Update health monitor has failed." ) `
#	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
#	-OR ( $_.Name -eq "Proactive Microsoft Windows Server 2012 Group Policy EventId 1096 Monitor" ) `
#	-OR ( $_.Name -eq "Proactive Microsoft Windows Server 2016 Group Policy EventId 1096 Monitor" ) `
#	-OR ( $_.Name -eq "Group Policy Client Service Not Running" ) `
#	}  | ? { ( $_.TimeRaised -ge $Time ) }
	
$GroupPolicyRuleAlerts = get-SCOMAlert -name "Policy Update Failure" | ? { ( $_.TimeRaised -ge $Time ) }
	#	| ? { $_.ResolutionState -ne "255"}

$GroupPolicyAlerts.Count
$GroupPolicyRuleAlerts.Count



# Open GroupPolicy alerts
$GroupPolicyOpenAlerts = $GroupPolicyAlerts	| ? { ( $_.ResolutionState -ne "255" ) }
$GroupPolicyOpenAlerts.Count

# Open GroupPolicy alerts since last report
$GroupPolicyAlertsSinceReport = $GroupPolicyAlerts | ? { ( $_.TimeRaised -ge $Time ) }
$GroupPolicyAlertsSinceReport.Count

# Closed GroupPolicy alerts
$ClosedGroupPolicyAlerts = $GroupPolicyAlerts | ? { ( $_.ResolutionState -eq "255" ) }
$ClosedGroupPolicyAlerts.Count

# Open GroupPolicy alerts
$GroupPolicyOpenRuleAlerts = $GroupPolicyRuleAlerts | ? { ( $_.ResolutionState -ne "255" ) }
$GroupPolicyOpenRuleAlerts.Count

# Open GroupPolicy alerts since last report
$GroupPolicySinceReportRuleAlerts = $GroupPolicyRuleAlerts | ? { ( $_.TimeRaised -ge $Time ) }
$GroupPolicySinceReportRuleAlerts.Count

# Closed GroupPolicy alerts
$GroupPolicyClosedRuleAlerts = $GroupPolicyRuleAlerts | ? { ( $_.ResolutionState -eq "255" ) }
$GroupPolicyClosedRuleAlerts.Count



$GroupPolicyServerAlertArray = @()
#$GroupPolicyServerAlertArray.Count


# Group Policy GPO alerts
$GPOAlerts = $GroupPolicyAlerts | ? { ( $_.Name -eq "The Group Policy Update health monitor has failed." ) `
	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	-OR ( $_.Name -eq "Policy Update Failure" ) `
	}

$GPOAlerts.Count

$OpenGPOalerts = $GPOAlerts | ? { $_.ResolutionState -ne "255" }
$OpenGPOAlerts.Count

$ClosedGPOAlerts = $GPOAlerts | ? { $_.ResolutionState -eq "255" }
$ClosedGPOAlerts.Count


	
# Test variable
$Test = $GroupPolicyAlerts.count + $GroupPolicySinceReportRuleAlerts.Count
$Test


#
# Remaining alerts - not Proactive
$GroupPolicyRemaining = @()
$GroupPolicyRemaining = $GroupPolicyOpenAlerts | ? { ( $_.Name -ne "The Group Policy Update health monitor has failed." ) `
	-AND ( $_.Name -ne "Group policy processing aborted - cannot determine site" ) `
	-AND ( $_.Name -ne "Proactive Microsoft Windows Server 2016 Group Policy EventId 1096 Monitor" ) `
	-AND ( $_.Name -ne "Group Policy Client Service Not Running" ) `
	-AND ( $_.Name -ne "Policy Update Failure" ) `
	}
	#| ? { $_.ResolutionState -ne "255" }
	#| ? { ( $_.Name -eq "The Group Policy Update health monitor has failed." ) `
	#	-OR ( $_.Name -eq "Group policy processing aborted - cannot determine site" ) `
	#	-OR ( $_.Name -eq "Proactive Microsoft Windows Server 2012 Group Policy EventId 1096 Monitor" ) `
	#	-OR ( $_.Name -eq "Proactive Microsoft Windows Server 2016 Group Policy EventId 1096 Monitor" ) `
	#	-OR ( $_.Name -eq "Group Policy Client Service Not Running" ) `
	#	}  | ? { ( $_.TimeRaised -ge $Time ) }

$GroupPolicyRemaining

$GroupPolicyFormattedRemaining = $GroupPolicyRemaining | select NetbiosComputerName,TimeRaised,Name



# Build report
$GroupPolicyTeamReport = @()


# Check for alerts 
if ( $GroupPolicyAlerts.Count -eq 0 )
	{
	$Message = "ZERO alerts for GroupPolicy Failure Daily report for ($date)"
	$GroupPolicyTeamReport += "ZERO alerts for GroupPolicy report for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}

if ( $GroupPolicyAlerts.Count -gt 0 )
	{
	#
	# Create table output

	#
	# Show ADDS alerts by Time Raised,NetBiosComputerName,Message
	#
	$GroupPolicyTeamReport += $Message
	$GroupPolicyTeamReport += ""
	$GroupPolicyTeamReport += "# GroupPolicy update failures Daily report for $($date)"
	$GroupPolicyTeamReport += "#"
	$GroupPolicyTeamReport += "# Alerts since last run = $($Test)"
	$GroupPolicyTeamReport += "#"
	$GroupPolicyTeamReport += "# Total OPEN alerts"
	$GroupPolicyTeamReport += "#========================================================"
	$GroupPolicyTeamReport += "# GroupPolicy alerts = $($GroupPolicyOpenAlerts.Count)"
	$GroupPolicyTeamReport += "# Policy Update Failure Rule alerts = $($GroupPolicyOpenRuleAlerts.Count)"
	$GroupPolicyTeamReport += ""
	$GroupPolicyTeamReport += "# Total CLOSED alerts"
	$GroupPolicyTeamReport += "#========================================================"	
	$GroupPolicyTeamReport += "# GroupPolicy alerts = $($ClosedGroupPolicyAlerts.Count)"
	$GroupPolicyTeamReport += "# Policy Update Failure Rule alerts = $($GroupPolicyClosedRuleAlerts.Count)"
	$GroupPolicyTeamReport += "#========================================================"
	$GroupPolicyTeamReport += ""


	if ( $GroupPolicyOpenAlerts.count -eq 0 )
		{
		$GroupPolicyTeamReport += "ZERO Group Policy Object issues for ($date)."
		$GroupPolicyTeamReport += ""
		}

	if ( $GroupPolicyOpenAlerts.count -gt 0 )
		{
		$GroupPolicyTeamReport += "# Group Policy Object (GPO) alert detail"
		$GroupPolicyTeamReport += "#============================================="
		$GroupPolicyTeamReport += $GroupPolicyOpenAlerts | select TimeRaised,NetbiosComputername,Description | out-string
		$GroupPolicyTeamReport += "#========================"
		$GroupPolicyTeamReport += ""
		}


	if ( $GroupPolicyOpenRuleAlerts.count -eq 0 )
		{
		$GroupPolicyTeamReport += "ZERO Policy Update Failure Rule issues for ($date)."
		$GroupPolicyTeamReport += ""
		}

	if ( $GroupPolicyOpenRuleAlerts.count -gt 0 )
		{
		$GroupPolicyTeamReport += "# Policy Update Failure Rule alert detail"
		$GroupPolicyTeamReport += "#============================================="
		$GroupPolicyTeamReport += $GroupPolicyOpenRuleAlerts | select TimeRaised,NetbiosComputername,Description | out-string
		$GroupPolicyTeamReport += "#========================"
		$GroupPolicyTeamReport += ""
		}


	if ( $GroupPolicyRemaining.count -eq 0 )
		{
		$GroupPolicyTeamReport += "ZERO GroupPolicy remaining Operating System and issues for ($date)."
		$GroupPolicyTeamReport += ""
		}

	if ( $GroupPolicyRemaining.count -gt 0 )
		{
		$GroupPolicyTeamReport += "# Other GroupPolicy application OR Operating System issues "
		$GroupPolicyTeamReport += "#============================================="
		$GroupPolicyTeamReport += $GroupPolicyRemaining | select NetBiosComputerName,TimeRaised,Name | out-string
		$GroupPolicyTeamReport += "#========================"
		$GroupPolicyTeamReport += ""
		}
	}

$GroupPolicyTeamReport


$GroupPolicyTeamReport = $ADDSTeamReport | out-string

#============================================================

$Result = "GOOD"
$Message = "GroupPolicy Daily report for ($date)"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"$GroupPolicyTeamReport")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$GroupPolicyTeamReport)

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>
      <DataSourceModuleType ID="Proactive.DailyTasks.Microsoft.Windows.2016.Eventlog.Full.Script.DataSource" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <DataSource ID="Scheduler" TypeID="System!System.Scheduler">
                <Scheduler>
                  <WeeklySchedule>
                    <Windows>
                      <Daily>
                        <Start>11:11</Start>
                        <End>11:31</End>
                        <DaysOfWeekMask>1</DaysOfWeekMask>
                      </Daily>
                    </Windows>
                  </WeeklySchedule>
                  <ExcludeDates />
                </Scheduler>
              </DataSource>
              <ProbeAction ID="PA" TypeID="Windows!Microsoft.Windows.PowerShellPropertyBagTriggerOnlyProbe">
          <ScriptName>Microsoft.Windows.2016.Eventlog.Full.Script.DataSource.v1059.ps1</ScriptName>
          <ScriptBody>
#=================================================================================
#  Script to check event log size, retention, and overwrite properties WHEN alert cuts for Event Log is full
#
#  Author:  Kevin Justin
#
#  Version:  1.0
#
#=================================================================================

# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging
$ScriptName = "Microsoft.Windows.2016.Eventlog.Full.Script.DataSource.v1059.ps1"
$EventID = "3750"
#=================================================================================

# Starting Script section
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#=================================================================================

# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================
# Monitor name = Event Log File is Full
# Located in OS packs = Windows Server 2012 Operating System (Monitoring)

$EventMessage = @()

# Debug
#$EventLog = "Message : The Application log file is full."
#
$EventLog = get-eventlog -logname System | ? { $_.EventId -eq 6000 } | sort -uniq | fl Message
$EventLog.Count

# Figure out EventLog
#==============================
if ( $EventLog.Count -gt 0 )
	{
	foreach ($LLine in $EventLog)
		{
		$Lmatch = $LLine |select-string -pattern 'The '
		if ($Lmatch)
			{
			#$Lmatch
			$LLineSplit = $LLine.Split(" ")
			#$LLineSplit
			#$LLineSplit[1]; $LLineSplit[2]
			$LLineSplit[3]
			#$LLineSplit2 = $LLineSplit[3].Split("Domain")
			#$LLineSplit2[0]
			$EventLogs += $LLineSplit[3]
			}
		}
	}

If ( $EventLogs.Count -gt 0 )
	{
	$EventMessage += "Event logs need properties updated"
	$EventMessage += ""
	foreach ($Events in $EventLogs)
		{ 
		$EventMessage += "NOTE: $($Events) Event Log will be updated"
		$EventMessage += ""
		$Properties = get-logproperties $Events 
		if ( $Properties.MaxLogSize -le "33554432" )
			{ 
			Limit-EventLog -LogName $Events -MaximumSize 64MB
			$EventMessage += "Set $($Events) EventLog to 64MB"
			}
		Limit-EventLog -LogName $Events  -RetentionDays 7 -OverflowAction OverwriteOlder
		$EventMessage += "Set $($Events) EventLog to 7 day retention AND Overwrite older events"
		}
	$Output = Get-EventLog -List

	$EventMessage += ""
	$EventMessage += "# EventLog details changed for $($EventLogs) Event Log"
	$EventMessage += "#==============================================="
	$EventMessage += $Output
	$EventMessage += "#==============================================="
	}


$EventMessage
# Verify output
$EventMessage = $EventMessage | out-string
$EventMessage


#Check the value of $strCondition
IF ( $EventLogs -eq 0 )
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"NO SME/SystemOwner/SysAdmin/Server action required")
	#$bag.AddValue('Result',"NO SME/SystemOwner/SysAdmin/Server action required")
	}

IF ( $EventLogs -gt 0 )
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$EventMessage")
	#============================================================
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n# Event logs need properties updated on ($date). `n `n$EventMessage")

	$Result = "GOOD"
	$Message = "Event logs need properties updated on ($date)"

	#$bag.AddValue('Result',$Result)
	$bag.AddValue('Count',$Test)
	$bag.AddValue('Message',$Message)
	$bag.AddValue('Summary',$EventMessage)

	# Return all bags
	$bag
	}
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
write-host "Script Completed. Script Runtime: ($ScriptTime) seconds."
#=================================================================================
# End of script
				</ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </ProbeAction>
            </MemberModules>
            <Composition>
              <Node ID="PA">
                <Node ID="Scheduler" />
              </Node>
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.PropertyBagData</OutputType>
      </DataSourceModuleType>

      <WriteActionModuleType ID="Proactive.DailyTasks.WINOSAlerts.2016.Close.Script.Alert.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" name="TimeoutSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.DailyTasks.WINOSAlerts.2016.Close.Script.Alert.WA.v1059.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to gather WINOS 2012 alerts and close via on demand task
#
#  Author: Kevin Justin
#  v1.0
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
# ScriptName should be the same as the ID of the module that the script is contained in
$ScriptName = "Proactive.DailyTasks.WINOSAlerts.2016.Close.Script.Alert.WA.v1059.ps1"
$EventID = "581"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# PropertyBag Script section - Monitoring scripts get this
#=================================================================================
# Load SCOM PropertyBag function
$bag = $momapi.CreatePropertyBag()
#=================================================================================


# Begin MAIN script section
#=================================================================================

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"
$Age = [DateTime](Get-Date).AddDays(-7)

# Grab past 24 hours
if ( (get-date).DayOfWeek -ne "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-1)
	}
if ( (get-date).DayOfWeek -eq "Monday" )
	{
	$Time = [DateTime](Get-Date).AddDays(-3)
	}
	
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather WINOS 2016+ Alerts for date ($date).")


# Gather WINOS alerts
## Grab the MP, get the Monitors and Rules from the MP, then grab all alerts found inside the Monitors/Rules
$SCOMCoreMP = Get-SCOMManagementPack -DisplayName "Windows Server 2016 and above Operating Systems (Monitoring)"
$SCOMCoreRules = $SCOMCoreMP.GetRules()
$SCOMCoreMonitors = $SCOMCoreMP.GetMonitors()

$SCOMCoreReportAlerts = Get-SCOMAlert -ResolutionState (0..254) | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$SCOMCoreReportAlerts.Count

$SCOMCoreRuleAlerts = $SCOMCoreReportAlerts | ? { ( $_.Name -in $SCOMCoreRules.DisplayName) }
$SCOMCoreRuleAlerts.Count

$SCOMCoreMonitorAlerts = $SCOMCoreReportAlerts | ? { ($_.Name -in $SCOMCoreMonitors.DisplayName ) }
$SCOMCoreMonitorAlerts.Count

# Open/Closed breakout
$OpenADDSAlerts = $SCOMCoreReportAlerts
$OpenADDSAlerts.Count
$ClosedADDSAlerts = Get-SCOMAlert -ResolutionState 255 | ? { ($_.Name -in $SCOMCoreRules.DisplayName) -or ($_.Name -in $SCOMCoreMonitors.DisplayName) }
$ClosedADDSAlerts.Count


#$Test = $ADFSAlerts.Count
$Test = $SCOMCoreMonitorAlerts.Count


#
# Build report
$WINOSAMessage = @()


if ( $SCOMCoreReportAlerts.count -eq 0 )
	{
	$Message = "ZERO WINOS 2016+ Monitors auto-closed for ($date)"
	$WINOSAMessage += "ZERO WINOS 2016+ Monitors auto-closed for ($date)"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$Message")
	}


if ( $SCOMCoreReportAlerts.count -gt 0 )
	{
	$WINOSAMessage += ""
	$WINOSAMessage += "Alert Count = $Test "
	$WINOSAMessage += ""
	$WINOSAMessage += "# WINOS 2016+ Monitors auto-closed"
	$WINOSAMessage += "#=========================================================="
	$WINOSAMessage += "# Number of open WINOS 2016+ alerts = $($SCOMCoreReportAlerts.Count)"
	$WINOSAMessage += "#=========================================================="
	$WINOSAMessage += ""
	$WINOSAMessage += "#==============================================="
	$WINOSAMessage += "# Monitors AND Rules that were auto closed = $($SCOMCoreReportAlerts.Count)"
	$WINOSAMessage += "#==============================================="
	$WINOSAMessage += ""
	#$WINOSAMessage += "#=============="
	#$WINOSAMessage += "# Alert details"
	#$WINOSAMessage += "#=============="
	#$WINOSAMessage += $SCOMCoreReportAlerts
	#$WINOSAMessage += ""
	#$WINOSAMessage += "#================================================"
	#$WINOSAMessage += "# List of included Monitor/Rule names auto-closed"
	#$WINOSAMessage += "#================================================"
	#$WINOSAMessage += "# Monitors"
	#$WINOSAMessage += $SCOMCoreMonitorAlerts
	#$WINOSAMessage += "# Rules"
	#$WINOSAMessage += $SCOMCoreRuleAlerts
	#$WINOSAMessage += "#============================================================"
	#$WINOSAMessage += ""

	$WINOSAMessage
	$WINOSAMessage = $WINOSAMessage | out-string
	}

#============================================================

$Result = "GOOD"
$Message = "WINOS Monitors auto-closed for ($date)"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Report completed for ($date). `n `n$WINOSAMessage")

#$bag.AddValue('Result',$Result)
$bag.AddValue('Count',$Test)
$bag.AddValue('Message',$Message)
$bag.AddValue('Summary',$WINOSAMessage)


# Return all bags
$bag
#=================================================================================


# Rule closure logic
#=================================================================================
$SCOMCoreRulesToClear = $SCOMCoreRuleAlerts | where { ( $_.TimeAdded -lt $Age ) }
# Convert Age back to days for alert properties logging
$Days = ((Get-date) - $Age).Days
if ( $SCOMCoreRulesToClear.Count -gt 0 )
	{
	$SCOMCoreRulesToClear | Resolve-SCOMAlert -Comment "Closing $Days day old alerts after report alert generated - ADDS Addendum Automation DS"
	}

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Proactive DailyTasks ADDS rule reset completed for ($date)")

#=================================================================================
# Reset Monitors Script base code modified
# Put ps1 in mgmtpacks folder
# https://sc.scomurr.com/scom-2012-monitor-reset-cleaning-up-the-environment/
#	Download
# https://gallery.technet.microsoft.com/SCOM-2012-Batch-reset-63a17534
	
#Alternate
#https://gallery.technet.microsoft.com/scriptcenter/Auto-reset-script-for-d8b775ca

# Changed up logic to sort unique classes in mgmnt pack families.
# Added Age variable for monitors thanks to Aris Somatis - $Age specified in top level variables
# Cycling through monitors made reset loop huge ~650 monitors when only ~50 classes
# New logic reduced runtime from 8 minutes to roughly 8 seconds
#=================================================================================

# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Monitor Reset automation started for ($date).")


if ( $SCOMCoreReportAlerts.Count -gt 0 )
	{
	# Get classes - Examples: Microsoft.Windows.Server.AD.2016.Discovery, Microsoft.Windows.Server.AD.Library
		$Library = Get-SCOMManagementPack -name "Microsoft.Windows.Server.Library"
		$Monitoring = $SCOMCoreMP
		$Discovery = Get-SCOMManagementPack -name Microsoft.Windows.Server.2016.Discovery

	# pack naming
	$OSClasses = @(Get-SCOMClass -ManagementPack $Library; Get-SCOMClass -ManagementPack $Discovery; )
	$OSClass = $OSClasses | sort -property Name -uniq
	# Debug
	$OSClass.Count

	# Set up monitor objects to reset
	foreach ($Class in $OSClass)
		{
		$ActiveMonitors = @(Get-SCOMClassInstance -Class $Class | ? { ($_.healthstate -ne 'Success') -AND ( $_.healthstate -ne 'Uninitialized') -AND ($_.IsAvailable -eq $true) } )
		# Debug
		$ActiveMonitors.Count
		# $ActiveMonitors | fl -property *
		write-host "Found" $ActiveMonitors.Count "unhealthy monitors for class" $Class
		foreach ( $UnhealthyOLDMonitor in $ActiveMonitors )
			{
			#if ( $UnhealthyOLDMonitor.AvailabilityLastModified -lt $Age )
			if ( $UnhealthyOLDMonitor.StateLastModified -lt $Age )
				{
				#$UnhealthyMonitors += $ActiveMonitors.Count
				#UnhealthyOLDMonitor | select AvailabilityLastModified,Path,DisplayName
				#$UnhealthyOLDMonitor.Count
				#write-host "Found" + $UnhealthyOLDMonitor.Count + "unhealthy monitor beyond" $Age "days."
				#write-host ""
				if ( $ActiveMonitors.Count -gt 0)
					{
					foreach ( $ActiveMonitor in $UnhealthyOLDMonitor )
						{
						# Debug
						$ActiveMonitor.ID
						write-host " Resetting Health State on '" + $ActiveMonitor.FullName + "'" 
						write-host ""
						$ActiveMonitor.ResetMonitoringState($ActiveMonitor)
						}
					}
				}
			}
		}
	# Debug
	#$MonitorClass | fl -property *
	#$MonitorClass | select DisplayName,ID
	}


# Debug Write event for rule closure
#=================================================================================
# Write event for rule closure
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS monitor reset completed for ($date)")

#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType ID="Proactive.Microsoft.Windows.2016.LogicalDisk.Cleanup.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:string" name="DriveLetter" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="DriveLetter" Selector="$Config/DriveLetter$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Proactive.Microsoft.Windows.2016.LogicalDisk.Cleanup.WA.v1059.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Proactive 2016+ logical disk cleanup manual task
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================
# param([string]$DriveLetter #,[string]$ComputerName)
param([string]$DriveLetter)


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ComputerName = "computername.domain.com"
$ComputerName = $env:ComputerName
#$DriveLetter = "C"
$DriveLetter
#=================================================================================
$ScriptName = "Proactive.Microsoft.Windows.2016.LogicalDisk.Cleanup.WA.v1059.ps1"
$EventID = "681"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
# Load PropertyBag function 
$bag = $momapi.CreatePropertyBag()

#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Script is starting. `n Running as ($whoami).")
#=================================================================================


# Begin MAIN script section
#=================================================================================
#Log script parameters we received
$momapi.LogScriptEvent($ScriptName,$EventID,0,"`nScript parameters passed into datasource: `nDriveLetter: ($DriveLetter). `nComputerName: ($ComputerName).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Gather Proactive Disk Cleanup Alert report for date ($date).")

$DSMessage = "Proactive Logical Disk Cleanup Alert for date ($date)."


# Check Disk free space
#=====================
if ($Driveletter -eq "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -eq "C:" }
	$CFreeSpace.DeviceID
	$CFreeSpace
	
 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }
 
	$DiskFreeSpace
 
	$SoftwareDistribution = (gci C:\windows\SoftwareDistribution | measure length -s).sum / 1Mb
	# Debug
	$SoftwareDistribution

	# Check for large profile sizes
	#==================================
	$Profiles = Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") -and ($_.localpath -notlike "C:\WINDOWS*"))}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }
	#$Profiles=Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") )}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }

	# Figure out C:\Users directory size
	$CUsersTableObject = @()

	#$OS = [Environment]::OSVersion
	$PSVersionTable.PSVersion.Major

	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$User = (gci $DriveLetter\users -Recurse -Depth 1 -EA 4 | measure length -s).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$User = (gci $DriveLetter\users -Recurse | measure length -s).sum
		}
		
	$UserSize = [math]::Round($User/1GB,2) 
	$CUsersTableObject += "$($UserSize) = Size of C:\Users directory"
	$CUsersTableObject += ""
	$CUsersTableObject
	
	$ProfileTableObject = @()
	
	# Loop through profiles
	foreach ($Profile in $Profiles)
		{
		$Profile
		#$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse | measure length -s).sum
			}

		$ProfileTableObject += [pscustomobject]@{	
		SizeGB = [math]::Round($Size/1GB,2)
		#AccountID = $Profile
		UserDirectory = "$Profile"
	      }
		}
	$ProfileTableObject | sort -property SizeGB -desc

	# Cleanup C:\Windows\Temp
	#=====================
	# May see access denied errors - Get-ChildItem
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse -Depth 1 -EA 4 | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse | Measure-Object -Property Length -Sum ).sum
		}
	}


# Non C Drive cleanup
#=============================
# Debug $Driveletter
#$Driveletter = "D"
#$Driveletter
if ($DriveLetter -ne "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

	$DeviceDriveLetter;	cd \
    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace
	}


# Check disk space (default C:)
#======================================= 
# Debug
$DriveLetter
#
If ($DiskFreeSpace.FreeSpace -gt 5 )
	{
	$strCondition = "Good"
	#$DSMessage = "NO ($DriveLetter) drive Cleanup required for date ($date)."
	$end
	}
 
If ($DiskFreeSpace.FreeSpace -lt 5 )
	{
	#$DriveLetter = "C:"
	#Set the condition = bad.  This represents your script finding something wrong
	$strCondition = "Bad"

	# Proactive C: drive Cleanup
	$resman= New-Object -ComObject "UIResource.UIResourceMgr"
	$cacheInfo=$resman.GetCacheInfo()
	$cacheinfo.GetCacheElements()  | foreach {$cacheInfo.DeleteCacheElement($_.CacheElementID)}


	# get-volume
	#=====================
	# $DriveLetter = "C"
	$ExpandC = get-volume
	$ExpandAction = $ExpandC | ? { ( $_.SizeRemaining -gt "0" ) -AND ( $_.Driveletter -eq "$DriveLetter" ) }
	
	if ( $ExpandAction.DriveLetter -eq $true)
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Expand drive via Disk Manager on ($ComputerName)")
		}


	# Check Disk free space AFTER cleanup
	#==================================
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID
 
	$DiskFreeSpace = [pscustomobject]@{
		DeviceID = $CFreeSpace.DeviceID
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
        }
 
	$DiskFreeSpace
 
	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter
 
	# Check C Drive folder size
	#==========================
	#$CheckCDriveFolders = (gci C:).Name | ? { ( $_ -ne "Users" ) -AND ( $_ -ne "Windows" )  }
	$CheckCDriveFolders = (gci $DeviceDriveLetter -directory).Name | ? { ( $_ -ne "Users" ) }
	$CheckCDriveFolders
 
	$Cfolders = @()
 
	Foreach ( $folder in $CheckCDriveFolders )
		{
		#$folder
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse -Depth 1 -EA SilentlyContinue | Measure-Object -Property Length -Sum ).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse | Measure-Object -Property Length -Sum ).sum
			}
		$Size

		$CFolders += [pscustomobject]@{
			Directory = $folder
			SizeGB = [math]::Round($Size/1GB,2)
			}
		}
	$Cfolders  #| sort -property SizeGB -desc


# Second attempt will clean up software distribution
#==================================
If ($DiskFreeSpace.FreeSpace -lt 15 )
	{
	# Audit Software Distribution
	#==================================
	If ( $SoftwareDistribution -lt "3000" )
		{
		Write-host "NO SME/SystemOwner/SysAdmin/Server Action required"
		}
		 
	If ( $SoftwareDistribution -gt "3000" )
		{
		Write-host "SME/SystemOwner/SysAdmin/Server Action required, stopping Windows Update service, removing SoftwareDIstribution folder and restarting"
		Get-Service -Name wuauserv | Stop-Service 
		Remove-Item -Path C:\Windows\SoftwareDistribution -Recurse
		Get-Service -Name wuauserv | Start-Service
		Write-host "Windows Update wuauserv service restarted after SoftwareDistribution directory removed"
		}

	# Cleanup IIS log files
	#=====================
	# if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC1 )
		# {
		# # Years older than
		# $HowOld = [DateTime]::Now.AddYears(-1)
		# $RecentUse = [DateTime]::Now.AddDays(-90)
		# # Path to root folder
		# $Path = "C:\inetpub\logs\LogFiles\W3SVC1\*.log"
		# # Deletion task
		# get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
		# }

	# if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC2 )
		# {
		# # Years older than
		# $HowOld = [DateTime]::Now.AddYears(-1)
		# $RecentUse = [DateTime]::Now.AddDays(-90)
		# # Path to root folder
		# $Path = "C:\inetpub\logs\LogFiles\W3SVC2\*.log"
		# # Deletion task
		# get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
		# }

	# # D drive Event cleanup
	# $DeviceDriveLetter
	# If ( $DeviceDriveLetter -eq "D:" )
		# {
		# If ( Test-Path "D:\Domain Event Logs\Domain Controllers" ) 
			# {
			# # Years older than 
			# $HowOld = [DateTime]::Now.AddYears(-2)
			# $RecentUse = [DateTime]::Now.AddDays(-7)
			# # Path to root folder 
			# $Path = "D:\Domain Event Logs\Domain Controllers\*.evt" 
			# # Deletion task 
			# get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
			# }
		
		# # Cleanup IIS log files
		# #=====================
		# if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC1 )
			# {
			# # Years older than 
			# $HowOld = [DateTime]::Now.AddYears(-1)
			# $RecentUse = [DateTime]::Now.AddDays(-90)
			# # Path to root folder
			# $Path = "D:\inetpub\logs\LogFiles\W3SVC1\*.log"
			# # Deletion task
			# get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
			# }

		# if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC2 )
			# {
			# # Years older than 
			# $HowOld = [DateTime]::Now.AddYears(-1)
			# $RecentUse = [DateTime]::Now.AddDays(-90)
			# # Path to root folder 
			# $Path = "D:\inetpub\logs\LogFiles\W3SVC2\*.log"
			# # Deletion task 
			# get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
			# }
		# }

		# # Example for VEEAM backup files
		# #================================
		# If ( Test-Path "D:\Backup" )
			# {
			# # Years older than
            # $HowOld = [DateTime]::Now.AddYears(-2)
            # $RecentUse = [DateTime]::Now.AddDays(-10)
			# # Path to root folder
            # $Path = "D:\Backup\*.v*"
			# # Deletion task
			# get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld `
				# -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
			# }

		# # Cleanup SQL Backup files
		# #=====================
		# # Example paths
		# # G:\Backup
		# # S:\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\Backup

		# if ( Test-Path "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup" )
			# {
			# # Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
			# # If older than 14 days
			# $HowOld= [DateTime]::Now.AddDays(-14)
			# $RecentUse = [DateTime]::Now.AddDays(-14)
			# # Path to root folder
			# $Path = "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
			# # Deletion task
			# get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
				# -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
			# }

		# if ( Test-Path "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup" )
			# {
			# # Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
			# # If older than 14 days
			# $HowOld= [DateTime]::Now.AddDays(-14)
			# $RecentUse = [DateTime]::Now.AddDays(-14)
			# # Path to root folder
			# $Path = "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
			# # Deletion task
			# get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
				# -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
			# }
		
		# if ( Test-Path "G:\Backup" )
			# {
			# # Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
			# # If older than 14 days 
			# $HowOld= [DateTime]::Now.AddDays(-14)
			# $RecentUse = [DateTime]::Now.AddDays(-14)
			# # Path to root folder
			# $Path = "G:\Backup\*.bak"
			# # Deletion task
			# get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
				# -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
			# }

	# Check folder size after cleanup
	#==========================
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
		}

	$After = [math]::Round($AfterSize/1GB,2)
	}


	# Summary Report
	#==================================
	$ProfileTableOutput = $ProfileTableObject | sort -property SizeGB -desc | out-string
	$CFolderOutput = $Cfolders | sort -property SizeGB -desc | out-string
	$Computer = $ENV:ComputerName

	$CdriveCleanupReport = @()
 
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += $DSMessage
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "# Server Drive audit on server $($Computer)"
	$CdriveCleanupReport += "# Server Drive = $($DriveLetter)"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "Before totals = $($Before) to after total = $($After)"
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "# Software Distribution folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $SoftwareDistribution | out-string
	$CdriveCleanupReport += ""

if ($Driveletter -eq "C" )
	{
	$CdriveCleanupReport += "# Audit of profiles for cleanup"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $ProfileTableOutput | out-string
	$CdriveCleanupReport += ""
	}

	$CdriveCleanupReport += "# Audit of folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $CFolderOutput | out-string
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "NOTE: Manual effort required:"
	$CdriveCleanupReport += "SME/SystemOwner/SysAdmin/Server SME required to clean up drive folders"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += ""
	}

# Verify output
$CdriveCleanupReport = $CdriveCleanupReport | out-string
$CdriveCleanupReport


#Check the value of $strCondition
IF ($strCondition -eq "Good")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"NO SME/SystemOwner/SysAdmin/Server action required")
	$bag.AddValue('Result',$strCondition)
	}
IF ($strCondition -eq "Bad")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$CdriveCleanupReport")
	$bag.AddValue('Result',$strCondition)
	$bag.AddValue('Summary',$CdriveCleanupReport)
	}

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
                </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
      <WriteActionModuleType ID="Microsoft.Windows.Server.2016.Eventlog.Service.WA" Accessibility="Internal" Batching="false">
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
        </OverrideableParameters>
        <ModuleImplementation Isolation="Any">
          <Composite>
            <MemberModules>
              <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
                <ScriptName>Microsoft.Windows.Server.2016.Eventlog.Service.WA.v1059.ps1</ScriptName>
                <ScriptBody>
#=================================================================================
#  Script to restart a service
#
#  Author:  Kevin Holman
#
#  Version:  1.0
#
#=================================================================================


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ServiceName = "Eventlog"
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging
$ScriptName = "Microsoft.Windows.Eventlog.Service.Monitor.Recovery.v1059.ps1"
$EventID = "3750"
#=================================================================================


# Starting Script section
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
#=================================================================================


# Begin MAIN script section
#=================================================================================

[string]$ServiceName = "Eventlog"

#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Recovery script for service: ($ServiceName) is starting. `n Running as ($whoami).")
write-host "Recovery script for service: ($ServiceName) is starting. Running as ($whoami)."

#Get the service object
$Svc = Get-Service $ServiceName

#Check to ensure the service exists:
IF (!$Svc)
	{
	$momapi.LogScriptEvent($ScriptName,3751,2, "Service ($ServiceName) was not found on this computer. `n This indicates a misconfiguration of the monitor. `n Error is ($error)")
	write-host "Service ($ServiceName) was not found on this computer. This indicates a misconfiguration of the monitor. Error is ($error)"
	EXIT
	}

#Get Service Status:
[string]$SvcStatus = $Svc.Status

#Do not continue is service is already running
IF ($SvcStatus -eq "Running")
	{
	$momapi.LogScriptEvent($ScriptName,3752,2, "Service ($ServiceName) was found to be in the Running state. `n This indicates a misconfiguration of the monitor. `n No recovery action will be taken.")
	write-host "Service ($ServiceName) was found to be in the Running state. This indicates a misconfiguration of the monitor. No recovery action will be taken."
	EXIT  
	}

#Log recovery information event
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Service: ($ServiceName) was found to be in the ($SvcStatus) state.  Recovery will be attempted.")
write-host "Service: ($ServiceName) was found to be in the ($SvcStatus) state.  Recovery will be attempted."

#Attempt First Recovery
Restart-Service -Name $ServiceName -Force
#Wait time in seconds
Start-Sleep 20
#Get the service object
$Svc = Get-Service $ServiceName
#Get Service Status:
$SvcStatus = $Svc.Status

IF ($SvcStatus -ne "Running")
	{
	#Attempt Second Recovery
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Service: ($ServiceName) second attempt at recovering starting now.")
	write-host "Service: ($ServiceName) second attempt at recovering starting now."
	Restart-Service -Name $ServiceName -Force
	Start-Sleep 20
	$Svc = Get-Service $ServiceName
	$SvcStatus = $Svc.Status
	}

IF ($SvcStatus -ne "Running")
	{
	#Attempt Third Recovery
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Service: ($ServiceName) third attempt at recovering starting now.")
	write-host "Service: ($ServiceName) third attempt at recovering starting now."
	Restart-Service -Name $ServiceName -Force
	Start-Sleep 20
	$Svc = Get-Service $ServiceName
	$SvcStatus = $Svc.Status
	}

IF ($SvcStatus -eq "Running")
	{
	#Log event of a successful restart
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Service: ($ServiceName) was successfully restarted and then detected to be in the Running state.")
	write-host "Service: ($ServiceName) was successfully restarted and then detected to be in the Running state."
	}
ELSE
	{
	#Log event of a successful restart
	$momapi.LogScriptEvent($ScriptName,3753,2,"`n Service: ($ServiceName) is not running. `n Recovery was attempted and failed. `n Manual interventon is required. `n The last detected service status was ($SvcStatus).") 
	write-host "Service: ($ServiceName) is not running. Recovery was attempted and failed. Manual interventon is required. The last detected service status was ($SvcStatus)."
	}

# Check to see if this recovery script has been run multiple times in the last x minutes for detection of too many recovery actions
$Message = "*($ServiceName) is starting*"
$Events = Get-EventLog -LogName 'Operations Manager' -After $StartTime.AddMinutes(-60) -Message $Message | where {$_.EventID -eq 3750}
$EventCount = $Events.Count
IF ($EventCount -ge 3)
	{
	$momapi.LogScriptEvent($ScriptName,3754,2,"`n Too many service recoveries have been attempted for ($ServiceName). `n ($EventCount) recoveries are detected in the event log. `n Manual interventon is required.")
	write-host "Too many service recoveries have been attempted for ($ServiceName). ($EventCount) recoveries are detected in the event log. Manual interventon is required."
	}

# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
write-host "Script Completed. Script Runtime: ($ScriptTime) seconds."
#=================================================================================
# End of script
		  </ScriptBody>
                <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
              </WriteAction>
            </MemberModules>
            <Composition>
              <Node ID="PSWA" />
            </Composition>
          </Composite>
        </ModuleImplementation>
        <OutputType>System!System.BaseData</OutputType>
        <InputType>System!System.BaseData</InputType>
      </WriteActionModuleType>
    </ModuleTypes>
    <MonitorTypes>
      <UnitMonitorType ID="Proactive.WINOS.Repeated.Event.MonitorType" Accessibility="Public">
        <MonitorTypeStates>
          <MonitorTypeState ID="RepeatedEventRaised" NoDetection="false" />
          <MonitorTypeState ID="TimerEventRaised" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="LogName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="ErrorExpression" type="ExpressionType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="AutoResolveInterval" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimerWindowInSeconds" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="RepeatCount" type="xsd:unsignedInt" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="ErrorDataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider">
              <ComputerName>$Config/ComputerName$</ComputerName>
              <LogName>$Config/LogName$</LogName>
            </DataSource>
            <ProbeAction ID="OnDemandReset" TypeID="System!System.PassThroughProbe" />
            <ConditionDetection ID="ErrorFilterCondition" TypeID="System!System.ExpressionFilter">
              <Expression>$Config/ErrorExpression$</Expression>
            </ConditionDetection>
            <ConditionDetection ID="RepeatedDataCondition" TypeID="System!System.ConsolidatorCondition">
              <Consolidator>
                <ConsolidationProperties />
                <TimeControl>
                  <WithinTimeSchedule>
                    <Interval>$Config/TimerWindowInSeconds$</Interval>
                  </WithinTimeSchedule>
                </TimeControl>
                <CountingCondition>
                  <Count>$Config/RepeatCount$</Count>
                  <CountMode>OnNewItemTestOutputRestart_OnTimerSlideByOne</CountMode>
                </CountingCondition>
              </Consolidator>
            </ConditionDetection>
            <ConditionDetection ID="TimerCondition" TypeID="System!System.TimerCondition">
              <TimerWaitInSeconds>$Config/AutoResolveInterval$</TimerWaitInSeconds>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="RepeatedEventRaised">
              <Node ID="RepeatedDataCondition">
                <Node ID="ErrorFilterCondition">
                  <Node ID="ErrorDataSource" />
                </Node>
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="TimerEventRaised">
              <Node ID="TimerCondition">
                <Node ID="RepeatedDataCondition">
                  <Node ID="ErrorFilterCondition">
                    <Node ID="ErrorDataSource" />
                  </Node>
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
          <OnDemandDetections>
            <OnDemandDetection MonitorTypeStateID="TimerEventRaised">
              <Node ID="OnDemandReset" />
            </OnDemandDetection>
          </OnDemandDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Proactive.Microsoft.Windows.SingleEventLogTimer2StateMonitorType" Accessibility="Public">
        <MonitorTypeStates>
          <MonitorTypeState ID="EventRaised" NoDetection="false" />
          <MonitorTypeState ID="TimerEventRaised" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <IncludeSchemaTypes>
            <SchemaType>System!System.ExpressionEvaluatorSchema</SchemaType>
          </IncludeSchemaTypes>
          <xsd:element name="ComputerName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="LogName" type="xsd:string" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="Expression" type="ExpressionType" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="TimerWaitInSeconds" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element name="MatchCount" type="xsd:integer" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="MatchCount" Selector="$Config/MatchCount$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DataSource" TypeID="Windows!Microsoft.Windows.BaseEventProvider">
              <ComputerName>$Config/ComputerName$</ComputerName>
              <LogName>$Config/LogName$</LogName>
            </DataSource>
            <ProbeAction ID="OnDemandReset" TypeID="System!System.PassThroughProbe" />
            <ConditionDetection ID="FilterCondition" TypeID="System!System.ExpressionFilter">
              <Expression>$Config/Expression$</Expression>
            </ConditionDetection>
            <ConditionDetection ID="TimerCondition" TypeID="System!System.TimerCondition">
              <TimerWaitInSeconds>$Config/TimerWaitInSeconds$</TimerWaitInSeconds>
            </ConditionDetection>
            <ConditionDetection ID="ThresholdNotBreached" TypeID="System!System.LogicalSet.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Double">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>LessEqual</Operator>
                  <ValueExpression>
                    <Value Type="Double">$Config/MatchCount$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <EmptySet>Block</EmptySet>
              <SetEvaluation>Any</SetEvaluation>
            </ConditionDetection>
            <ConditionDetection ID="ThresholdBreached" TypeID="System!System.LogicalSet.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="Double">Value</XPathQuery>
                  </ValueExpression>
                  <Operator>Greater</Operator>
                  <ValueExpression>
                    <Value Type="Double">$Config/MatchCount$</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <EmptySet>Passthrough</EmptySet>
              <SetEvaluation>Any</SetEvaluation>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="EventRaised">
              <Node ID="FilterCondition">
                <Node ID="DataSource" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="TimerEventRaised">
              <Node ID="TimerCondition">
                <Node ID="FilterCondition">
                  <Node ID="DataSource" />
                </Node>
              </Node>
            </RegularDetection>
          </RegularDetections>
          <OnDemandDetections>
            <OnDemandDetection MonitorTypeStateID="TimerEventRaised">
              <Node ID="OnDemandReset" />
            </OnDemandDetection>
          </OnDemandDetections>
        </MonitorImplementation>
      </UnitMonitorType>
      <UnitMonitorType ID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Monitor.MonitorType" Accessibility="Internal">
        <MonitorTypeStates>
          <MonitorTypeState ID="GoodCondition" NoDetection="false" />
          <MonitorTypeState ID="BadCondition" NoDetection="false" />
        </MonitorTypeStates>
        <Configuration>
          <xsd:element minOccurs="1" type="xsd:string" name="DriveLetter" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" type="xsd:integer" name="TimeoutSeconds" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
          <xsd:element minOccurs="1" type="xsd:integer" name="MatchCount" xmlns:xsd="http://www.w3.org/2001/XMLSchema" />
        </Configuration>
        <OverrideableParameters>
          <OverrideableParameter ID="DriveLetter" Selector="$Config/DriveLetter$" ParameterType="string" />
          <OverrideableParameter ID="TimeoutSeconds" Selector="$Config/TimeoutSeconds$" ParameterType="int" />
          <OverrideableParameter ID="MatchCount" Selector="$Config/MatchCount$" ParameterType="int" />
        </OverrideableParameters>
        <MonitorImplementation>
          <MemberModules>
            <DataSource ID="DS" TypeID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Monitor.Datasource">
              <DriveLetter>$Config/DriveLetter$</DriveLetter>
              <TimeoutSeconds>$Config/TimeoutSeconds$</TimeoutSeconds>
            </DataSource>
            <ConditionDetection ID="GoodConditionFilter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='Result']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">GoodCondition</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
            </ConditionDetection>
            <ConditionDetection ID="BadConditionFilter" TypeID="System!System.ExpressionFilter">
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">Property[@Name='Result']</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">BadCondition</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <SuppressionSettings>
                <MatchCount>$Config/MatchCount$</MatchCount>
              </SuppressionSettings>
            </ConditionDetection>
          </MemberModules>
          <RegularDetections>
            <RegularDetection MonitorTypeStateID="GoodCondition">
              <Node ID="GoodConditionFilter">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
            <RegularDetection MonitorTypeStateID="BadCondition">
              <Node ID="BadConditionFilter">
                <Node ID="DS" />
              </Node>
            </RegularDetection>
          </RegularDetections>
          <OnDemandDetections>
            <OnDemandDetection MonitorTypeStateID="GoodCondition">
              <Node ID="GoodConditionFilter">
                <Node ID="DS" />
              </Node>
            </OnDemandDetection>
            <OnDemandDetection MonitorTypeStateID="BadCondition">
              <Node ID="BadConditionFilter">
                <Node ID="DS" />
              </Node>
            </OnDemandDetection>
          </OnDemandDetections>
        </MonitorImplementation>
      </UnitMonitorType>
    </MonitorTypes>
  </TypeDefinitions>
  <Monitoring>
    <Rules>
      <Rule ID="Proactive.DailyTasks.WINOSAlerts.Report.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.DailyTasks.WINOSAlerts.Close.Script.DataSource">
            <TimeoutSeconds>900</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.WINOSAlerts.Report.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Count']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Message']$</AlertParameter2>
              <AlertParameter3>$Data/Property[@Name='Summary']$</AlertParameter3>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Message']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.WINOSAlerts.Report.Script.Task.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">550</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern> WINOS Monitors auto-closed for </Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.WINOSAlerts.Report.Script.Task.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.GroupPolicy.2016.Report.Script.Alert.Rule" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.DailyTasks.GroupPolicy.2016.Report.Script.DataSource">
            <TimeoutSeconds>900</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.GroupPolicy.2016.Report.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Count']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Message']$</AlertParameter2>
              <AlertParameter3>$Data/Property[@Name='Summary']$</AlertParameter3>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Message']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Script.Task.Alert.Rule" Enabled="false" Target="MWS6D!Microsoft.Windows.Server.10.0.Computer" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">681</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Proactive Logical Disk Cleanup Alert task for date</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Script.Task.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Task.Alert.Rule" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.Computer" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">680</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">EventDescription</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>action required to fix group policy on server</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Task.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.2016.Eventlog.Service.NotFound.Recovery.Rule" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">3751</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">Params/Param[2]</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Eventlog</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.2016.Eventlog.Service.NotFound.Recovery.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data[Default='']/EventDisplayNumber$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/PublisherName$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/LoggingComputer$</SuppressionValue>
            </Suppression>
            <Custom1 />
            <Custom2 />
            <Custom3 />
            <Custom4 />
            <Custom5 />
            <Custom6 />
            <Custom7 />
            <Custom8 />
            <Custom9 />
            <Custom10 />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.2016.Eventlog.Service.FoundRunning.Recovery.Rule" Enabled="false" Target="MWS6D!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">3752</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">Params/Param[2]</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Eventlog</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.2016.Eventlog.Service.FoundRunning.Recovery.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data[Default='']/EventDisplayNumber$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/PublisherName$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/LoggingComputer$</SuppressionValue>
            </Suppression>
            <Custom1 />
            <Custom2 />
            <Custom3 />
            <Custom4 />
            <Custom5 />
            <Custom6 />
            <Custom7 />
            <Custom8 />
            <Custom9 />
            <Custom10 />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.2016.Eventlog.Service.RecoveryFailed.Recovery.Rule" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">3753</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">Params/Param[2]</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Eventlog</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.2016.Eventlog.Service.RecoveryFailed.Recovery.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data[Default='']/EventDisplayNumber$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/PublisherName$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/LoggingComputer$</SuppressionValue>
            </Suppression>
            <Custom1 />
            <Custom2 />
            <Custom3 />
            <Custom4 />
            <Custom5 />
            <Custom6 />
            <Custom7 />
            <Custom8 />
            <Custom9 />
            <Custom10 />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Microsoft.Windows.Server.2016.Eventlog.Service.TooManyRecoveryAttempts.Recovery.Rule" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.OperatingSystem" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Windows!Microsoft.Windows.EventProvider">
            <ComputerName>$Target/Host/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
            <LogName>Operations Manager</LogName>
            <Expression>
              <And>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="UnsignedInteger">3754</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <SimpleExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">PublisherName</XPathQuery>
                    </ValueExpression>
                    <Operator>Equal</Operator>
                    <ValueExpression>
                      <Value Type="String">Health Service Script</Value>
                    </ValueExpression>
                  </SimpleExpression>
                </Expression>
                <Expression>
                  <RegExExpression>
                    <ValueExpression>
                      <XPathQuery Type="String">Params/Param[2]</XPathQuery>
                    </ValueExpression>
                    <Operator>ContainsSubstring</Operator>
                    <Pattern>Eventlog</Pattern>
                  </RegExExpression>
                </Expression>
              </And>
            </Expression>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="Alert" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>1</Severity>
            <AlertName />
            <AlertDescription />
            <AlertOwner />
            <AlertMessageId>$MPElement[Name="Microsoft.Windows.Server.2016.Eventlog.Service.TooManyRecoveryAttempts.Recovery.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/EventDescription$</AlertParameter1>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data[Default='']/EventDisplayNumber$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/PublisherName$</SuppressionValue>
              <SuppressionValue>$Data[Default='']/LoggingComputer$</SuppressionValue>
            </Suppression>
            <Custom1 />
            <Custom2 />
            <Custom3 />
            <Custom4 />
            <Custom5 />
            <Custom6 />
            <Custom7 />
            <Custom8 />
            <Custom9 />
            <Custom10 />
          </WriteAction>
        </WriteActions>
      </Rule>
      <Rule ID="Proactive.DailyTasks.Microsoft.Windows.2016.Eventlog.Full.Script.Alert.Rule" Enabled="false" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" ConfirmDelivery="true" Remotable="true" Priority="Normal" DiscardLevel="100">
        <Category>Alert</Category>
        <DataSources>
          <DataSource ID="DS" TypeID="Proactive.DailyTasks.Microsoft.Windows.2016.Eventlog.Full.Script.DataSource">
            <TimeoutSeconds>900</TimeoutSeconds>
          </DataSource>
        </DataSources>
        <WriteActions>
          <WriteAction ID="WA" TypeID="Health!System.Health.GenerateAlert">
            <Priority>1</Priority>
            <Severity>0</Severity>
            <AlertMessageId>$MPElement[Name="Proactive.DailyTasks.Microsoft.Windows.2016.Eventlog.Full.Script.Alert.Rule.AlertMessage"]$</AlertMessageId>
            <AlertParameters>
              <AlertParameter1>$Data/Property[@Name='Count']$</AlertParameter1>
              <AlertParameter2>$Data/Property[@Name='Message']$</AlertParameter2>
              <AlertParameter3>$Data/Property[@Name='Summary']$</AlertParameter3>
            </AlertParameters>
            <Suppression>
              <SuppressionValue>$Data/Property[@Name='Message']$</SuppressionValue>
            </Suppression>
          </WriteAction>
        </WriteActions>
      </Rule>
    </Rules>
    <Tasks>
      <Task ID="Proactive.DailyTasks.WINOSAlerts.Report.Script.Task" Accessibility="Public" Enabled="true" Target="SC!Microsoft.SystemCenter.AllManagementServersPool" Timeout="120" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.DailyTasks.WINOSAlerts.2016.Close.Script.Alert.WA">
          <TimeoutSeconds>900</TimeoutSeconds>
        </WriteAction>
      </Task>
      <Task ID="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.Task" Accessibility="Public" Enabled="false" Target="MWS6D!Microsoft.Windows.Server.10.0.Computer" Timeout="300" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.Microsoft.Windows.2016.LogicalDisk.Cleanup.WA">
          <DriveLetter>C</DriveLetter>
          <TimeoutSeconds>3000</TimeoutSeconds>
        </WriteAction>
      </Task>
      <Task ID="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.Task" Accessibility="Public" Enabled="false" Target="MWS6D!Microsoft.Windows.Server.10.0.Computer" Timeout="300" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Proactive.Microsoft.Windows.2016.LogicalDisk.Cleanup.WA">
          <DriveLetter>D</DriveLetter>
          <TimeoutSeconds>3000</TimeoutSeconds>
        </WriteAction>
      </Task>
      <Task ID="Proactive.Microsoft.Windows.Server.2016.Eventlog.Service.Task" Accessibility="Public" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.OperatingSystem" Timeout="300" Remotable="true">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Microsoft.Windows.Server.2016.Eventlog.Service.WA">
          <TimeoutSeconds>600</TimeoutSeconds>
        </WriteAction>
      </Task>
    </Tasks>
    <Monitors>
      <UnitMonitor ID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor" Accessibility="Public" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.Computer" ParentMonitorID="MWSL!Microsoft.Windows.Server.Computer.HardwareAvailabilityAggregate" Remotable="true" Priority="Normal" RunAs="System!System.PrivilegedMonitoringAccount" TypeID="Proactive.Microsoft.Windows.SingleEventLogTimer2StateMonitorType" ConfirmDelivery="false">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor.AlertMessage">
          <AlertOnState>Error</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>High</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
            <AlertParameter2>$Data/Context/DataItem/EventDescription$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="TimerEventRaised" MonitorTypeStateID="TimerEventRaised" HealthState="Success" />
          <OperationalState ID="EventRaised" MonitorTypeStateID="EventRaised" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <LogName>System</LogName>
          <Expression>
            <And>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="UnsignedInteger">153</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">PublisherName</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">Disk</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">EventDescription</XPathQuery>
                  </ValueExpression>
                  <Operator>DoesNotMatchRegularExpression</Operator>
                  <Pattern>^(The IO operation at logical block address.*for Disk 3.*retried.)|^(The IO operation at logical block address.*for Disk 4.*retried.)$</Pattern>
                </RegExExpression>
              </Expression>
            </And>
          </Expression>
          <TimerWaitInSeconds>3600</TimerWaitInSeconds>
          <MatchCount>5</MatchCount>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Secondary.Monitor" Accessibility="Public" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.Computer" ParentMonitorID="MWSL!Microsoft.Windows.Server.Computer.HardwareAvailabilityAggregate" Remotable="true" Priority="Normal" RunAs="System!System.PrivilegedMonitoringAccount" TypeID="Proactive.Microsoft.Windows.SingleEventLogTimer2StateMonitorType" ConfirmDelivery="false">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Secondary.Monitor.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>High</AlertPriority>
          <AlertSeverity>Warning</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/PrincipalName$</AlertParameter1>
            <AlertParameter2>$Data/Context/DataItem/EventDescription$</AlertParameter2>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="TimerEventRaised" MonitorTypeStateID="TimerEventRaised" HealthState="Success" />
          <OperationalState ID="EventRaised" MonitorTypeStateID="EventRaised" HealthState="Error" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <LogName>System</LogName>
          <Expression>
            <And>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="UnsignedInteger">153</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">PublisherName</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">Disk</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">EventDescription</XPathQuery>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>^(The IO operation at logical block address.*for Disk 3.*retried.)|^(The IO operation at logical block address.*for Disk 4.*retried.)$</Pattern>
                </RegExExpression>
              </Expression>
            </And>
          </Expression>
          <TimerWaitInSeconds>3600</TimerWaitInSeconds>
          <MatchCount>5</MatchCount>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor" Accessibility="Public" Enabled="false" Target="MWS6D!Microsoft.Windows.Server.10.0.Computer" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Monitor.MonitorType" ConfirmDelivery="true">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='Summary']$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="GoodCondition" MonitorTypeStateID="GoodCondition" HealthState="Success" />
          <OperationalState ID="BadCondition" MonitorTypeStateID="BadCondition" HealthState="Warning" />
        </OperationalStates>
        <Configuration>
          <DriveLetter>C</DriveLetter>
          <TimeoutSeconds>600</TimeoutSeconds>
          <MatchCount>1</MatchCount>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor" Accessibility="Public" Enabled="false" Target="MWS6D!Microsoft.Windows.Server.10.0.Computer" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Monitor.MonitorType" ConfirmDelivery="true">
        <Category>AvailabilityHealth</Category>
        <AlertSettings AlertMessage="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>Normal</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/Property[@Name='Summary']$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="GoodCondition" MonitorTypeStateID="GoodCondition" HealthState="Success" />
          <OperationalState ID="BadCondition" MonitorTypeStateID="BadCondition" HealthState="Warning" />
        </OperationalStates>
        <Configuration>
          <DriveLetter>D</DriveLetter>
          <TimeoutSeconds>600</TimeoutSeconds>
          <MatchCount>1</MatchCount>
        </Configuration>
      </UnitMonitor>
      <UnitMonitor ID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor" Accessibility="Public" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.Computer" ParentMonitorID="Health!System.Health.ConfigurationState" Remotable="true" Priority="Normal" TypeID="Proactive.WINOS.Repeated.Event.MonitorType" ConfirmDelivery="true">
        <Category>ConfigurationHealth</Category>
        <AlertSettings AlertMessage="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor.AlertMessage">
          <AlertOnState>Warning</AlertOnState>
          <AutoResolve>true</AutoResolve>
          <AlertPriority>High</AlertPriority>
          <AlertSeverity>MatchMonitorHealth</AlertSeverity>
          <AlertParameters>
            <AlertParameter1>$Data/Context/EventDescription$</AlertParameter1>
          </AlertParameters>
        </AlertSettings>
        <OperationalStates>
          <OperationalState ID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor.Timer" MonitorTypeStateID="TimerEventRaised" HealthState="Success" />
          <OperationalState ID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor.Repeated" MonitorTypeStateID="RepeatedEventRaised" HealthState="Warning" />
        </OperationalStates>
        <Configuration>
          <ComputerName>$Target/Property[Type="Windows!Microsoft.Windows.Computer"]/NetworkName$</ComputerName>
          <LogName>System</LogName>
          <ErrorExpression>
            <And>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="UnsignedInteger">EventDisplayNumber</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="UnsignedInteger">1096</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <SimpleExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">PublisherName</XPathQuery>
                  </ValueExpression>
                  <Operator>Equal</Operator>
                  <ValueExpression>
                    <Value Type="String">Microsoft-Windows-GroupPolicy</Value>
                  </ValueExpression>
                </SimpleExpression>
              </Expression>
              <Expression>
                <RegExExpression>
                  <ValueExpression>
                    <XPathQuery Type="String">EventDescription</XPathQuery>
                  </ValueExpression>
                  <Operator>MatchesRegularExpression</Operator>
                  <Pattern>^(Windows could not apply the registry-based policy settings for the Group Policy)$</Pattern>
                </RegExExpression>
              </Expression>
            </And>
          </ErrorExpression>
          <AutoResolveInterval>3700</AutoResolveInterval>
          <TimerWindowInSeconds>3600</TimerWindowInSeconds>
          <RepeatCount>5</RepeatCount>
        </Configuration>
      </UnitMonitor>
    </Monitors>
    <Recoveries>
      <Recovery ID="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.Recovery" Accessibility="Public" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.LogicalDisk" Monitor="MWS6M!Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor" ResetMonitor="true" ExecuteOnState="Warning" Remotable="true" Timeout="600">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
          <ScriptName>Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.Recovery.v1059.ps1</ScriptName>
          <ScriptBody>
#=================================================================================
#  Proactive logical disk cleanup recovery
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================
# param([string]$DriveLetter #,[string]$ComputerName)
#param([string]$DriveLetter)


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ComputerName = "computername.domain.com"
$ComputerName = $env:ComputerName
$DriveLetter = "C"
$DriveLetter
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
$ScriptName = "Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.Recovery.v1059.ps1"
$EventID = "680"
#=================================================================================


# Begin MAIN script section
#=================================================================================
#Log script parameters we received
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script parameters passed into datasource: `nDriveLetter: ($DriveLetter). `nComputerName: ($ComputerName).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive Disk Cleanup Alert report for date ($date).")

$DSMessage = "Proactive Logical Disk Cleanup Alert for date ($date)."


# Check Disk free space
#=====================
if ($Driveletter -eq "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -eq "C:" }
	$CFreeSpace.DeviceID
	$CFreeSpace

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace

	$SoftwareDistribution = (gci C:\windows\SoftwareDistribution | measure length -s).sum / 1Mb
	# Debug
	$SoftwareDistribution

	# Check for large profile sizes
	#==================================
	$Profiles = Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") -and ($_.localpath -notlike "C:\WINDOWS*"))}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }
	#$Profiles=Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") )}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }

	# Figure out C:\Users directory size
	$CUsersTableObject = @()

	#$OS = [Environment]::OSVersion
	$PSVersionTable.PSVersion.Major

	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$User = (gci $DriveLetter\users -Recurse -Depth 1 -EA 4 | measure length -s).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$User = (gci $DriveLetter\users -Recurse | measure length -s).sum
		}

	$UserSize = [math]::Round($User/1GB,2) 
	$CUsersTableObject += "$($UserSize) = Size of C:\Users directory"
	$CUsersTableObject += ""
	$CUsersTableObject

	$ProfileTableObject = @()

	# Loop through profiles
	foreach ($Profile in $Profiles)
		{
		$Profile
		#$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse | measure length -s).sum
			}

		$ProfileTableObject += [pscustomobject]@{	
		SizeGB = [math]::Round($Size/1GB,2)
		#AccountID = $Profile
		UserDirectory = "$Profile"
	      }
		}
	$ProfileTableObject | sort -property SizeGB -desc

	# Cleanup C:\Windows\Temp
	#=====================
	# May see access denied errors - Get-ChildItem
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse -Depth 1 -EA 4 | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse | Measure-Object -Property Length -Sum ).sum
		}
	}


# Non C Drive cleanup
#=============================
# Debug $Driveletter
#$Driveletter = "D"
#$Driveletter
if ($DriveLetter -ne "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

	$DeviceDriveLetter;	cd \
    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace
	}


# Check disk space (default C:)
#======================================= 
# Debug
$DriveLetter
#
If ($DiskFreeSpace.FreeSpace -gt 5 )
	{
	$strCondition = "Good"
	#$DSMessage = "NO ($DriveLetter) drive Cleanup required for date ($date)."
	$end
	}
 
If ($DiskFreeSpace.FreeSpace -lt 5 )
	{
	#$DriveLetter = "C:"
	#Set the condition = bad.  This represents your script finding something wrong
	$strCondition = "Bad"

	# Proactive C: drive Cleanup
	$resman= New-Object -ComObject "UIResource.UIResourceMgr"
	$cacheInfo=$resman.GetCacheInfo()
	$cacheinfo.GetCacheElements()  | foreach {$cacheInfo.DeleteCacheElement($_.CacheElementID)}


	# get-volume
	#=====================
	# $DriveLetter = "C"
	$ExpandC = get-volume
	$ExpandAction = $ExpandC | ? { ( $_.SizeRemaining -gt "0" ) -AND ( $_.Driveletter -eq "$DriveLetter" ) }

	if ( $ExpandAction.DriveLetter -eq $true)
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Expand drive via Disk Manager on ($ComputerName)")
		}


	# Check Disk free space AFTER cleanup
	#==================================
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

	$DiskFreeSpace = [pscustomobject]@{
		DeviceID = $CFreeSpace.DeviceID
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
        }

	$DiskFreeSpace

	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter
 
	# Check C Drive folder size
	#==========================
	#$CheckCDriveFolders = (gci C:).Name | ? { ( $_ -ne "Users" ) -AND ( $_ -ne "Windows" )  }
	$CheckCDriveFolders = (gci $DeviceDriveLetter -directory).Name | ? { ( $_ -ne "Users" ) }
	$CheckCDriveFolders

	$Cfolders = @()

	Foreach ( $folder in $CheckCDriveFolders )
		{
		#$folder
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse -Depth 1 -EA SilentlyContinue | Measure-Object -Property Length -Sum ).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse | Measure-Object -Property Length -Sum ).sum
			}
		$Size

		$CFolders += [pscustomobject]@{
			Directory = $folder
			SizeGB = [math]::Round($Size/1GB,2)
			}
		}
	$Cfolders  #| sort -property SizeGB -desc


# Second attempt will clean up software distribution
#==================================
If ($DiskFreeSpace.FreeSpace -lt 15 )
	{
	# Audit Software Distribution
	#==================================
	If ( $SoftwareDistribution -lt "3000" )
		{
		Write-host "NO SME/SystemOwner/SysAdmin/Server Action required"
		}

	If ( $SoftwareDistribution -gt "3000" )
		{
		Write-host "SME/SystemOwner/SysAdmin/Server Action required, stopping Windows Update service, removing SoftwareDIstribution folder and restarting"
		Get-Service -Name wuauserv | Stop-Service 
		Remove-Item -Path C:\Windows\SoftwareDistribution -Recurse 
		Get-Service -Name wuauserv | Start-Service
		Write-host "Windows Update wuauserv service restarted after SoftwareDistribution directory removed"
		}

	# Cleanup IIS log files
	#=====================
	#if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC1 )
	#	{
	#	# Years older than 
	#	$HowOld = [DateTime]::Now.AddYears(-1)
	#	$RecentUse = [DateTime]::Now.AddDays(-90)
	#	# Path to root folder 
	#	$Path = "C:\inetpub\logs\LogFiles\W3SVC1\*.log" 
	#	# Deletion task 
	#	get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#	}

	#if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC2 )
	#	{
	#	# Years older than 
	#	$HowOld = [DateTime]::Now.AddYears(-1)
	#	$RecentUse = [DateTime]::Now.AddDays(-90)
	#	# Path to root folder 
	#	$Path = "C:\inetpub\logs\LogFiles\W3SVC2\*.log"
	#	# Deletion task 
	#	get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#	}

	# D drive Event cleanup
	#$DeviceDriveLetter
	#If ( $DeviceDriveLetter -eq "D:" )
	#	{
	#	If ( Test-Path "D:\Domain Event Logs\Domain Controllers" )
	#		{
	#		# Years older than 
	#		$HowOld = [DateTime]::Now.AddYears(-2)
	#		$RecentUse = [DateTime]::Now.AddDays(-7) 
	#		# Path to root folder 
	#		$Path = "D:\Domain Event Logs\Domain Controllers\*.evt"
	#		# Deletion task
	#		get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}
		
		# Cleanup IIS log files
		#=====================
	#	if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC1 )
	#		{
	#		# Years older than
	#		$HowOld = [DateTime]::Now.AddYears(-1)
	#		$RecentUse = [DateTime]::Now.AddDays(-90)
	#		# Path to root folder
	#		$Path = "D:\inetpub\logs\LogFiles\W3SVC1\*.log"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC2 )
	#		{
	#		# Years older than
	#		$HowOld = [DateTime]::Now.AddYears(-1)
	#		$RecentUse = [DateTime]::Now.AddDays(-90)
	#		# Path to root folder
	#		$Path = "D:\inetpub\logs\LogFiles\W3SVC2\*.log"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}
	#	}

		# Example for VEEAM backup files
		#================================
	#	If ( Test-Path "D:\Backup" )
	#		{
	#		# Years older than
    #       $HowOld = [DateTime]::Now.AddYears(-2)
    #       $RecentUse = [DateTime]::Now.AddDays(-8)
	#		# Path to root folder
    #       $Path = "D:\Backup\*.v*"
	#		# Deletion task
	#		get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld `
	#			-and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

		# Cleanup SQL Backup files
		#=====================
		# Example paths
		# G:\Backup
		# S:\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\Backup

	#	if ( Test-Path "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup" )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path "G:\Backup )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "G:\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	# Check folder size after cleanup
	#==========================
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
		}

	$After = [math]::Round($AfterSize/1GB,2)
	}


	# Summary Report
	#==================================
	$ProfileTableOutput = $ProfileTableObject | sort -property SizeGB -desc | out-string
	$CFolderOutput = $Cfolders | sort -property SizeGB -desc | out-string
	$Computer = $ENV:ComputerName

	$CdriveCleanupReport = @()
 
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += $DSMessage
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "# Server Drive audit on server $($Computer)"
	$CdriveCleanupReport += "# Server Drive = $($DriveLetter)"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "Before totals = $($Before) to after total = $($After)"
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "# Software Distribution folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $SoftwareDistribution | out-string
	$CdriveCleanupReport += ""

if ($Driveletter -eq "C" )
	{
	$CdriveCleanupReport += "# Audit of profiles for cleanup"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $ProfileTableOutput | out-string
	$CdriveCleanupReport += ""
	}

	$CdriveCleanupReport += "# Audit of folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $CFolderOutput | out-string
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "NOTE: Manual effort required:"
	$CdriveCleanupReport += "SME/SystemOwner/SysAdmin/Server SME required to clean up drive folders"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += ""
	}

# Verify output
$CdriveCleanupReport = $CdriveCleanupReport | out-string
$CdriveCleanupReport


#Check the value of $strCondition
IF ($strCondition -eq "Good")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"NO SME/SystemOwner/SysAdmin/Server action required")
	$bag.AddValue('Result',$strCondition)
	}
IF ($strCondition -eq "Bad")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$CdriveCleanupReport")
	$bag.AddValue('Result',$strCondition)
	$bag.AddValue('Summary',$CdriveCleanupReport)
	}

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Cleanup Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
		  </ScriptBody>
          <TimeoutSeconds>360</TimeoutSeconds>
        </WriteAction>
      </Recovery>
      <Recovery ID="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.Recovery" Accessibility="Public" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.LogicalDisk" Monitor="MWS6M!Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor" ResetMonitor="true" ExecuteOnState="Warning" Remotable="true" Timeout="600">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
          <ScriptName>Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.Recovery.v1059.ps1</ScriptName>
          <ScriptBody>
#=================================================================================
#  Proactive logical disk cleanup recovery
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================
# param([string]$DriveLetter #,[string]$ComputerName)
#param([string]$DriveLetter)


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ComputerName = "computername.domain.com"
$ComputerName = $env:ComputerName
$DriveLetter = "D"
$DriveLetter
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
$ScriptName = "Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.Recovery.v1059.ps1"
$EventID = "680"
#=================================================================================


# Begin MAIN script section
#=================================================================================
#Log script parameters we received
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script parameters passed into datasource: `nDriveLetter: ($DriveLetter). `nComputerName: ($ComputerName).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive Disk Cleanup Alert report for date ($date).")

$DSMessage = "Proactive Logical Disk Cleanup Alert for date ($date)."


# Check Disk free space
#=====================
if ($Driveletter -eq "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -eq "C:" }
	$CFreeSpace.DeviceID
	$CFreeSpace

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace

	$SoftwareDistribution = (gci C:\windows\SoftwareDistribution | measure length -s).sum / 1Mb
	# Debug
	$SoftwareDistribution

	# Check for large profile sizes
	#==================================
	$Profiles = Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") -and ($_.localpath -notlike "C:\WINDOWS*"))}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }
	#$Profiles=Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") )}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }

	# Figure out C:\Users directory size
	$CUsersTableObject = @()

	#$OS = [Environment]::OSVersion
	$PSVersionTable.PSVersion.Major

	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$User = (gci $DriveLetter\users -Recurse -Depth 1 -EA 4 | measure length -s).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$User = (gci $DriveLetter\users -Recurse | measure length -s).sum
		}

	$UserSize = [math]::Round($User/1GB,2) 
	$CUsersTableObject += "$($UserSize) = Size of C:\Users directory"
	$CUsersTableObject += ""
	$CUsersTableObject

	$ProfileTableObject = @()

	# Loop through profiles
	foreach ($Profile in $Profiles)
		{
		$Profile
		#$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse | measure length -s).sum
			}

		$ProfileTableObject += [pscustomobject]@{	
		SizeGB = [math]::Round($Size/1GB,2)
		#AccountID = $Profile
		UserDirectory = "$Profile"
	      }
		}
	$ProfileTableObject | sort -property SizeGB -desc

	# Cleanup C:\Windows\Temp
	#=====================
	# May see access denied errors - Get-ChildItem
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse -Depth 1 -EA 4 | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse | Measure-Object -Property Length -Sum ).sum
		}
	}


# Non C Drive cleanup
#=============================
# Debug $Driveletter
#$Driveletter = "D"
#$Driveletter
if ($DriveLetter -ne "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

	$DeviceDriveLetter;	cd \
    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace
	}


# Check disk space (default C:)
#======================================= 
# Debug
$DriveLetter
#
If ($DiskFreeSpace.FreeSpace -gt 5 )
	{
	$strCondition = "Good"
	#$DSMessage = "NO ($DriveLetter) drive Cleanup required for date ($date)."
	$end
	}
 
If ($DiskFreeSpace.FreeSpace -lt 5 )
	{
	#$DriveLetter = "C:"
	#Set the condition = bad.  This represents your script finding something wrong
	$strCondition = "Bad"

	# Proactive C: drive Cleanup
	$resman= New-Object -ComObject "UIResource.UIResourceMgr"
	$cacheInfo=$resman.GetCacheInfo()
	$cacheinfo.GetCacheElements()  | foreach {$cacheInfo.DeleteCacheElement($_.CacheElementID)}


	# get-volume
	#=====================
	# $DriveLetter = "C"
	$ExpandC = get-volume
	$ExpandAction = $ExpandC | ? { ( $_.SizeRemaining -gt "0" ) -AND ( $_.Driveletter -eq "$DriveLetter" ) }

	if ( $ExpandAction.DriveLetter -eq $true)
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Expand drive via Disk Manager on ($ComputerName)")
		}


	# Check Disk free space AFTER cleanup
	#==================================
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

	$DiskFreeSpace = [pscustomobject]@{
		DeviceID = $CFreeSpace.DeviceID
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
        }

	$DiskFreeSpace

	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter
 
	# Check C Drive folder size
	#==========================
	#$CheckCDriveFolders = (gci C:).Name | ? { ( $_ -ne "Users" ) -AND ( $_ -ne "Windows" )  }
	$CheckCDriveFolders = (gci $DeviceDriveLetter -directory).Name | ? { ( $_ -ne "Users" ) }
	$CheckCDriveFolders

	$Cfolders = @()

	Foreach ( $folder in $CheckCDriveFolders )
		{
		#$folder
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse -Depth 1 -EA SilentlyContinue | Measure-Object -Property Length -Sum ).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse | Measure-Object -Property Length -Sum ).sum
			}
		$Size

		$CFolders += [pscustomobject]@{
			Directory = $folder
			SizeGB = [math]::Round($Size/1GB,2)
			}
		}
	$Cfolders  #| sort -property SizeGB -desc


# Second attempt will clean up software distribution
#==================================
If ($DiskFreeSpace.FreeSpace -lt 15 )
	{
	# Audit Software Distribution
	#==================================
	If ( $SoftwareDistribution -lt "3000" )
		{
		Write-host "NO SME/SystemOwner/SysAdmin/Server Action required"
		}

	If ( $SoftwareDistribution -gt "3000" )
		{
		Write-host "SME/SystemOwner/SysAdmin/Server Action required, stopping Windows Update service, removing SoftwareDIstribution folder and restarting"
		Get-Service -Name wuauserv | Stop-Service 
		Remove-Item -Path C:\Windows\SoftwareDistribution -Recurse 
		Get-Service -Name wuauserv | Start-Service
		Write-host "Windows Update wuauserv service restarted after SoftwareDistribution directory removed"
		}

	# Cleanup IIS log files
	#=====================
	#if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC1 )
	#	{
	#	# Years older than 
	#	$HowOld = [DateTime]::Now.AddYears(-1)
	#	$RecentUse = [DateTime]::Now.AddDays(-90)
	#	# Path to root folder 
	#	$Path = "C:\inetpub\logs\LogFiles\W3SVC1\*.log" 
	#	# Deletion task 
	#	get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#	}

	#if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC2 )
	#	{
	#	# Years older than 
	#	$HowOld = [DateTime]::Now.AddYears(-1)
	#	$RecentUse = [DateTime]::Now.AddDays(-90)
	#	# Path to root folder 
	#	$Path = "C:\inetpub\logs\LogFiles\W3SVC2\*.log"
	#	# Deletion task 
	#	get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#	}

	# D drive Event cleanup
	#$DeviceDriveLetter
	#If ( $DeviceDriveLetter -eq "D:" )
	#	{
	#	If ( Test-Path "D:\Domain Event Logs\Domain Controllers" )
	#		{
	#		# Years older than 
	#		$HowOld = [DateTime]::Now.AddYears(-2)
	#		$RecentUse = [DateTime]::Now.AddDays(-7) 
	#		# Path to root folder 
	#		$Path = "D:\Domain Event Logs\Domain Controllers\*.evt"
	#		# Deletion task
	#		get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}
		
		# Cleanup IIS log files
		#=====================
	#	if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC1 )
	#		{
	#		# Years older than
	#		$HowOld = [DateTime]::Now.AddYears(-1)
	#		$RecentUse = [DateTime]::Now.AddDays(-90)
	#		# Path to root folder
	#		$Path = "D:\inetpub\logs\LogFiles\W3SVC1\*.log"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC2 )
	#		{
	#		# Years older than
	#		$HowOld = [DateTime]::Now.AddYears(-1)
	#		$RecentUse = [DateTime]::Now.AddDays(-90)
	#		# Path to root folder
	#		$Path = "D:\inetpub\logs\LogFiles\W3SVC2\*.log"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}
	#	}

		# Example for VEEAM backup files
		#================================
	#	If ( Test-Path "D:\Backup" )
	#		{
	#		# Years older than
    #       $HowOld = [DateTime]::Now.AddYears(-2)
    #       $RecentUse = [DateTime]::Now.AddDays(-8)
	#		# Path to root folder
    #       $Path = "D:\Backup\*.v*"
	#		# Deletion task
	#		get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld `
	#			-and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

		# Cleanup SQL Backup files
		#=====================
		# Example paths
		# G:\Backup
		# S:\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\Backup

	#	if ( Test-Path "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup" )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path "G:\Backup )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "G:\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	# Check folder size after cleanup
	#==========================
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
		}

	$After = [math]::Round($AfterSize/1GB,2)
	}


	# Summary Report
	#==================================
	$ProfileTableOutput = $ProfileTableObject | sort -property SizeGB -desc | out-string
	$CFolderOutput = $Cfolders | sort -property SizeGB -desc | out-string
	$Computer = $ENV:ComputerName

	$CdriveCleanupReport = @()
 
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += $DSMessage
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "# Server Drive audit on server $($Computer)"
	$CdriveCleanupReport += "# Server Drive = $($DriveLetter)"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "Before totals = $($Before) to after total = $($After)"
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "# Software Distribution folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $SoftwareDistribution | out-string
	$CdriveCleanupReport += ""

if ($Driveletter -eq "C" )
	{
	$CdriveCleanupReport += "# Audit of profiles for cleanup"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $ProfileTableOutput | out-string
	$CdriveCleanupReport += ""
	}

	$CdriveCleanupReport += "# Audit of folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $CFolderOutput | out-string
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "NOTE: Manual effort required:"
	$CdriveCleanupReport += "SME/SystemOwner/SysAdmin/Server SME required to clean up drive folders"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += ""
	}

# Verify output
$CdriveCleanupReport = $CdriveCleanupReport | out-string
$CdriveCleanupReport


#Check the value of $strCondition
IF ($strCondition -eq "Good")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"NO SME/SystemOwner/SysAdmin/Server action required")
	$bag.AddValue('Result',$strCondition)
	}
IF ($strCondition -eq "Bad")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$CdriveCleanupReport")
	$bag.AddValue('Result',$strCondition)
	$bag.AddValue('Summary',$CdriveCleanupReport)
	}

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Cleanup Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
		  </ScriptBody>
          <TimeoutSeconds>360</TimeoutSeconds>
        </WriteAction>
      </Recovery>
      <Recovery ID="Proactive.Microsoft.Windows.LogicalDisk.C2.Cleanup.Monitor.Recovery" Accessibility="Public" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.LogicalDisk" Monitor="MWS6M!Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="600">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
          <ScriptName>Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.Recovery.v1059.ps1</ScriptName>
          <ScriptBody>
#=================================================================================
#  Proactive logical disk cleanup recovery
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================
# param([string]$DriveLetter #,[string]$ComputerName)
#param([string]$DriveLetter)


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ComputerName = "computername.domain.com"
$ComputerName = $env:ComputerName
$DriveLetter = "C"
$DriveLetter
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
$ScriptName = "Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.Recovery.v1059.ps1"
$EventID = "680"
#=================================================================================


# Begin MAIN script section
#=================================================================================
#Log script parameters we received
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script parameters passed into datasource: `nDriveLetter: ($DriveLetter). `nComputerName: ($ComputerName).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive Disk Cleanup Alert report for date ($date).")

$DSMessage = "Proactive Logical Disk Cleanup Alert for date ($date)."


# Check Disk free space
#=====================
if ($Driveletter -eq "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -eq "C:" }
	$CFreeSpace.DeviceID
	$CFreeSpace

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace

	$SoftwareDistribution = (gci C:\windows\SoftwareDistribution | measure length -s).sum / 1Mb
	# Debug
	$SoftwareDistribution

	# Check for large profile sizes
	#==================================
	$Profiles = Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") -and ($_.localpath -notlike "C:\WINDOWS*"))}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }
	#$Profiles=Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") )}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }

	# Figure out C:\Users directory size
	$CUsersTableObject = @()

	#$OS = [Environment]::OSVersion
	$PSVersionTable.PSVersion.Major

	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$User = (gci $DriveLetter\users -Recurse -Depth 1 -EA 4 | measure length -s).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$User = (gci $DriveLetter\users -Recurse | measure length -s).sum
		}

	$UserSize = [math]::Round($User/1GB,2) 
	$CUsersTableObject += "$($UserSize) = Size of C:\Users directory"
	$CUsersTableObject += ""
	$CUsersTableObject

	$ProfileTableObject = @()

	# Loop through profiles
	foreach ($Profile in $Profiles)
		{
		$Profile
		#$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse | measure length -s).sum
			}

		$ProfileTableObject += [pscustomobject]@{	
		SizeGB = [math]::Round($Size/1GB,2)
		#AccountID = $Profile
		UserDirectory = "$Profile"
	      }
		}
	$ProfileTableObject | sort -property SizeGB -desc

	# Cleanup C:\Windows\Temp
	#=====================
	# May see access denied errors - Get-ChildItem
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse -Depth 1 -EA 4 | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse | Measure-Object -Property Length -Sum ).sum
		}
	}


# Non C Drive cleanup
#=============================
# Debug $Driveletter
#$Driveletter = "D"
#$Driveletter
if ($DriveLetter -ne "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

	$DeviceDriveLetter;	cd \
    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace
	}


# Check disk space (default C:)
#======================================= 
# Debug
$DriveLetter
#
If ($DiskFreeSpace.FreeSpace -gt 5 )
	{
	$strCondition = "Good"
	#$DSMessage = "NO ($DriveLetter) drive Cleanup required for date ($date)."
	$end
	}
 
If ($DiskFreeSpace.FreeSpace -lt 5 )
	{
	#$DriveLetter = "C:"
	#Set the condition = bad.  This represents your script finding something wrong
	$strCondition = "Bad"

	# Proactive C: drive Cleanup
	$resman= New-Object -ComObject "UIResource.UIResourceMgr"
	$cacheInfo=$resman.GetCacheInfo()
	$cacheinfo.GetCacheElements()  | foreach {$cacheInfo.DeleteCacheElement($_.CacheElementID)}


	# get-volume
	#=====================
	# $DriveLetter = "C"
	$ExpandC = get-volume
	$ExpandAction = $ExpandC | ? { ( $_.SizeRemaining -gt "0" ) -AND ( $_.Driveletter -eq "$DriveLetter" ) }

	if ( $ExpandAction.DriveLetter -eq $true)
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Expand drive via Disk Manager on ($ComputerName)")
		}


	# Check Disk free space AFTER cleanup
	#==================================
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

	$DiskFreeSpace = [pscustomobject]@{
		DeviceID = $CFreeSpace.DeviceID
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
        }

	$DiskFreeSpace

	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter
 
	# Check C Drive folder size
	#==========================
	#$CheckCDriveFolders = (gci C:).Name | ? { ( $_ -ne "Users" ) -AND ( $_ -ne "Windows" )  }
	$CheckCDriveFolders = (gci $DeviceDriveLetter -directory).Name | ? { ( $_ -ne "Users" ) }
	$CheckCDriveFolders

	$Cfolders = @()

	Foreach ( $folder in $CheckCDriveFolders )
		{
		#$folder
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse -Depth 1 -EA SilentlyContinue | Measure-Object -Property Length -Sum ).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse | Measure-Object -Property Length -Sum ).sum
			}
		$Size

		$CFolders += [pscustomobject]@{
			Directory = $folder
			SizeGB = [math]::Round($Size/1GB,2)
			}
		}
	$Cfolders  #| sort -property SizeGB -desc


# Second attempt will clean up software distribution
#==================================
If ($DiskFreeSpace.FreeSpace -lt 15 )
	{
	# Audit Software Distribution
	#==================================
	If ( $SoftwareDistribution -lt "3000" )
		{
		Write-host "NO SME/SystemOwner/SysAdmin/Server Action required"
		}

	If ( $SoftwareDistribution -gt "3000" )
		{
		Write-host "SME/SystemOwner/SysAdmin/Server Action required, stopping Windows Update service, removing SoftwareDIstribution folder and restarting"
		Get-Service -Name wuauserv | Stop-Service 
		Remove-Item -Path C:\Windows\SoftwareDistribution -Recurse 
		Get-Service -Name wuauserv | Start-Service
		Write-host "Windows Update wuauserv service restarted after SoftwareDistribution directory removed"
		}

	# Cleanup IIS log files
	#=====================
	#if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC1 )
	#	{
	#	# Years older than 
	#	$HowOld = [DateTime]::Now.AddYears(-1)
	#	$RecentUse = [DateTime]::Now.AddDays(-90)
	#	# Path to root folder 
	#	$Path = "C:\inetpub\logs\LogFiles\W3SVC1\*.log" 
	#	# Deletion task 
	#	get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#	}

	#if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC2 )
	#	{
	#	# Years older than 
	#	$HowOld = [DateTime]::Now.AddYears(-1)
	#	$RecentUse = [DateTime]::Now.AddDays(-90)
	#	# Path to root folder 
	#	$Path = "C:\inetpub\logs\LogFiles\W3SVC2\*.log"
	#	# Deletion task 
	#	get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#	}

	# D drive Event cleanup
	#$DeviceDriveLetter
	#If ( $DeviceDriveLetter -eq "D:" )
	#	{
	#	If ( Test-Path "D:\Domain Event Logs\Domain Controllers" )
	#		{
	#		# Years older than 
	#		$HowOld = [DateTime]::Now.AddYears(-2)
	#		$RecentUse = [DateTime]::Now.AddDays(-7) 
	#		# Path to root folder 
	#		$Path = "D:\Domain Event Logs\Domain Controllers\*.evt"
	#		# Deletion task
	#		get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}
		
		# Cleanup IIS log files
		#=====================
	#	if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC1 )
	#		{
	#		# Years older than
	#		$HowOld = [DateTime]::Now.AddYears(-1)
	#		$RecentUse = [DateTime]::Now.AddDays(-90)
	#		# Path to root folder
	#		$Path = "D:\inetpub\logs\LogFiles\W3SVC1\*.log"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC2 )
	#		{
	#		# Years older than
	#		$HowOld = [DateTime]::Now.AddYears(-1)
	#		$RecentUse = [DateTime]::Now.AddDays(-90)
	#		# Path to root folder
	#		$Path = "D:\inetpub\logs\LogFiles\W3SVC2\*.log"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}
	#	}

		# Example for VEEAM backup files
		#================================
	#	If ( Test-Path "D:\Backup" )
	#		{
	#		# Years older than
    #       $HowOld = [DateTime]::Now.AddYears(-2)
    #       $RecentUse = [DateTime]::Now.AddDays(-8)
	#		# Path to root folder
    #       $Path = "D:\Backup\*.v*"
	#		# Deletion task
	#		get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld `
	#			-and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

		# Cleanup SQL Backup files
		#=====================
		# Example paths
		# G:\Backup
		# S:\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\Backup

	#	if ( Test-Path "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup" )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path "G:\Backup )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "G:\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	# Check folder size after cleanup
	#==========================
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
		}

	$After = [math]::Round($AfterSize/1GB,2)
	}


	# Summary Report
	#==================================
	$ProfileTableOutput = $ProfileTableObject | sort -property SizeGB -desc | out-string
	$CFolderOutput = $Cfolders | sort -property SizeGB -desc | out-string
	$Computer = $ENV:ComputerName

	$CdriveCleanupReport = @()
 
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += $DSMessage
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "# Server Drive audit on server $($Computer)"
	$CdriveCleanupReport += "# Server Drive = $($DriveLetter)"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "Before totals = $($Before) to after total = $($After)"
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "# Software Distribution folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $SoftwareDistribution | out-string
	$CdriveCleanupReport += ""

if ($Driveletter -eq "C" )
	{
	$CdriveCleanupReport += "# Audit of profiles for cleanup"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $ProfileTableOutput | out-string
	$CdriveCleanupReport += ""
	}

	$CdriveCleanupReport += "# Audit of folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $CFolderOutput | out-string
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "NOTE: Manual effort required:"
	$CdriveCleanupReport += "SME/SystemOwner/SysAdmin/Server SME required to clean up drive folders"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += ""
	}

# Verify output
$CdriveCleanupReport = $CdriveCleanupReport | out-string
$CdriveCleanupReport


#Check the value of $strCondition
IF ($strCondition -eq "Good")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"NO SME/SystemOwner/SysAdmin/Server action required")
	$bag.AddValue('Result',$strCondition)
	}
IF ($strCondition -eq "Bad")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$CdriveCleanupReport")
	$bag.AddValue('Result',$strCondition)
	$bag.AddValue('Summary',$CdriveCleanupReport)
	}

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Cleanup Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
		  </ScriptBody>
          <TimeoutSeconds>360</TimeoutSeconds>
        </WriteAction>
      </Recovery>
      <Recovery ID="Proactive.Microsoft.Windows.LogicalDisk.D2.Cleanup.Monitor.Recovery" Accessibility="Public" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.LogicalDisk" Monitor="MWS6M!Microsoft.Windows.Server.10.0.Legacy.LogicalDisk.FreeSpace.Monitor" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="600">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
          <ScriptName>Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.Recovery.v1059.ps1</ScriptName>
          <ScriptBody>
#=================================================================================
#  Proactive logical disk cleanup recovery
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================
# param([string]$DriveLetter #,[string]$ComputerName)
#param([string]$DriveLetter)


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ComputerName = "computername.domain.com"
$ComputerName = $env:ComputerName
$DriveLetter = "D"
$DriveLetter
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
$ScriptName = "Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.Recovery.v1059.ps1"
$EventID = "680"
#=================================================================================


# Begin MAIN script section
#=================================================================================
#Log script parameters we received
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script parameters passed into datasource: `nDriveLetter: ($DriveLetter). `nComputerName: ($ComputerName).")

#For a simple example - get files in Windows Temp:
$date = get-date -uFormat "%Y-%m-%d"

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive Disk Cleanup Alert report for date ($date).")

$DSMessage = "Proactive Logical Disk Cleanup Alert for date ($date)."


# Check Disk free space
#=====================
if ($Driveletter -eq "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -eq "C:" }
	$CFreeSpace.DeviceID
	$CFreeSpace

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace

	$SoftwareDistribution = (gci C:\windows\SoftwareDistribution | measure length -s).sum / 1Mb
	# Debug
	$SoftwareDistribution

	# Check for large profile sizes
	#==================================
	$Profiles = Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") -and ($_.localpath -notlike "C:\WINDOWS*"))}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }
	#$Profiles=Get-WmiObject -Class Win32_UserProfile |Select-Object localpath|where {(($_.localpath -notlike "*Administrator") )}| Foreach-Object { $_.LocalPath.split(‘\’)[-1] }

	# Figure out C:\Users directory size
	$CUsersTableObject = @()

	#$OS = [Environment]::OSVersion
	$PSVersionTable.PSVersion.Major

	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$User = (gci $DriveLetter\users -Recurse -Depth 1 -EA 4 | measure length -s).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$User = (gci $DriveLetter\users -Recurse | measure length -s).sum
		}

	$UserSize = [math]::Round($User/1GB,2) 
	$CUsersTableObject += "$($UserSize) = Size of C:\Users directory"
	$CUsersTableObject += ""
	$CUsersTableObject

	$ProfileTableObject = @()

	# Loop through profiles
	foreach ($Profile in $Profiles)
		{
		$Profile
		#$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse -Depth 1 -EA 4 | measure length -s).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (gci $DriveLetter\users\$Profile -Recurse | measure length -s).sum
			}

		$ProfileTableObject += [pscustomobject]@{	
		SizeGB = [math]::Round($Size/1GB,2)
		#AccountID = $Profile
		UserDirectory = "$Profile"
	      }
		}
	$ProfileTableObject | sort -property SizeGB -desc

	# Cleanup C:\Windows\Temp
	#=====================
	# May see access denied errors - Get-ChildItem
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse -Depth 1 -EA 4 | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		Get-ChildItem C:\Windows\Temp\ -Recurse | Remove-Item -Recurse -Force
		$WindowsTemp = (Get-ChildItem "C:\Windows\Temp\" -Recurse | Measure-Object -Property Length -Sum ).sum
		}
	}


# Non C Drive cleanup
#=============================
# Debug $Driveletter
#$Driveletter = "D"
#$Driveletter
if ($DriveLetter -ne "C" )
	{
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

 	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter

	# Check folder size after cleanup
	#==========================
	$BeforeSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
	$Before = [math]::Round($BeforeSize/1GB,2)

	$DeviceDriveLetter;	cd \
    $DiskFreeSpace = [pscustomobject]@{
		DeviceID = $DeviceDriveLetter
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
       }

	$DiskFreeSpace
	}


# Check disk space (default C:)
#======================================= 
# Debug
$DriveLetter
#
If ($DiskFreeSpace.FreeSpace -gt 5 )
	{
	$strCondition = "Good"
	#$DSMessage = "NO ($DriveLetter) drive Cleanup required for date ($date)."
	$end
	}
 
If ($DiskFreeSpace.FreeSpace -lt 5 )
	{
	#$DriveLetter = "C:"
	#Set the condition = bad.  This represents your script finding something wrong
	$strCondition = "Bad"

	# Proactive C: drive Cleanup
	$resman= New-Object -ComObject "UIResource.UIResourceMgr"
	$cacheInfo=$resman.GetCacheInfo()
	$cacheinfo.GetCacheElements()  | foreach {$cacheInfo.DeleteCacheElement($_.CacheElementID)}


	# get-volume
	#=====================
	# $DriveLetter = "C"
	$ExpandC = get-volume
	$ExpandAction = $ExpandC | ? { ( $_.SizeRemaining -gt "0" ) -AND ( $_.Driveletter -eq "$DriveLetter" ) }

	if ( $ExpandAction.DriveLetter -eq $true)
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Expand drive via Disk Manager on ($ComputerName)")
		}


	# Check Disk free space AFTER cleanup
	#==================================
	$CFreeSpace = gwmi win32_logicaldisk | ? { $_.DeviceID -like "$DriveLetter*" }
	$CFreeSpace.DeviceID

	$DiskFreeSpace = [pscustomobject]@{
		DeviceID = $CFreeSpace.DeviceID
		Size = [math]::Round($CFreeSpace.Size/1GB,2)
		FreeSpace = [math]::Round($CFreeSpace.FreeSpace/1GB,2)
        }

	$DiskFreeSpace

	$DeviceDriveLetter = $CFreeSpace.DeviceID
	$DeviceDriveLetter
 
	# Check C Drive folder size
	#==========================
	#$CheckCDriveFolders = (gci C:).Name | ? { ( $_ -ne "Users" ) -AND ( $_ -ne "Windows" )  }
	$CheckCDriveFolders = (gci $DeviceDriveLetter -directory).Name | ? { ( $_ -ne "Users" ) }
	$CheckCDriveFolders

	$Cfolders = @()

	Foreach ( $folder in $CheckCDriveFolders )
		{
		#$folder
		if ( $PSVersionTable.PSVersion.Major -gt 4 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse -Depth 1 -EA SilentlyContinue | Measure-Object -Property Length -Sum ).sum
			}
		if ( $PSVersionTable.PSVersion.Major -lt 5 )
			{
			$Size = (Get-ChildItem "$DeviceDriveLetter\$folder" -Force -Recurse | Measure-Object -Property Length -Sum ).sum
			}
		$Size

		$CFolders += [pscustomobject]@{
			Directory = $folder
			SizeGB = [math]::Round($Size/1GB,2)
			}
		}
	$Cfolders  #| sort -property SizeGB -desc


# Second attempt will clean up software distribution
#==================================
If ($DiskFreeSpace.FreeSpace -lt 15 )
	{
	# Audit Software Distribution
	#==================================
	If ( $SoftwareDistribution -lt "3000" )
		{
		Write-host "NO SME/SystemOwner/SysAdmin/Server Action required"
		}

	If ( $SoftwareDistribution -gt "3000" )
		{
		Write-host "SME/SystemOwner/SysAdmin/Server Action required, stopping Windows Update service, removing SoftwareDIstribution folder and restarting"
		Get-Service -Name wuauserv | Stop-Service 
		Remove-Item -Path C:\Windows\SoftwareDistribution -Recurse 
		Get-Service -Name wuauserv | Start-Service
		Write-host "Windows Update wuauserv service restarted after SoftwareDistribution directory removed"
		}

	# Cleanup IIS log files
	#=====================
	#if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC1 )
	#	{
	#	# Years older than 
	#	$HowOld = [DateTime]::Now.AddYears(-1)
	#	$RecentUse = [DateTime]::Now.AddDays(-90)
	#	# Path to root folder 
	#	$Path = "C:\inetpub\logs\LogFiles\W3SVC1\*.log" 
	#	# Deletion task 
	#	get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#	}

	#if ( Test-Path C:\inetpub\logs\LogFiles\W3SVC2 )
	#	{
	#	# Years older than 
	#	$HowOld = [DateTime]::Now.AddYears(-1)
	#	$RecentUse = [DateTime]::Now.AddDays(-90)
	#	# Path to root folder 
	#	$Path = "C:\inetpub\logs\LogFiles\W3SVC2\*.log"
	#	# Deletion task 
	#	get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#	}

	# D drive Event cleanup
	#$DeviceDriveLetter
	#If ( $DeviceDriveLetter -eq "D:" )
	#	{
	#	If ( Test-Path "D:\Domain Event Logs\Domain Controllers" )
	#		{
	#		# Years older than 
	#		$HowOld = [DateTime]::Now.AddYears(-2)
	#		$RecentUse = [DateTime]::Now.AddDays(-7) 
	#		# Path to root folder 
	#		$Path = "D:\Domain Event Logs\Domain Controllers\*.evt"
	#		# Deletion task
	#		get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}
		
		# Cleanup IIS log files
		#=====================
	#	if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC1 )
	#		{
	#		# Years older than
	#		$HowOld = [DateTime]::Now.AddYears(-1)
	#		$RecentUse = [DateTime]::Now.AddDays(-90)
	#		# Path to root folder
	#		$Path = "D:\inetpub\logs\LogFiles\W3SVC1\*.log"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path D:\inetpub\logs\LogFiles\W3SVC2 )
	#		{
	#		# Years older than
	#		$HowOld = [DateTime]::Now.AddYears(-1)
	#		$RecentUse = [DateTime]::Now.AddDays(-90)
	#		# Path to root folder
	#		$Path = "D:\inetpub\logs\LogFiles\W3SVC2\*.log"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}
	#	}

		# Example for VEEAM backup files
		#================================
	#	If ( Test-Path "D:\Backup" )
	#		{
	#		# Years older than
    #       $HowOld = [DateTime]::Now.AddYears(-2)
    #       $RecentUse = [DateTime]::Now.AddDays(-8)
	#		# Path to root folder
    #       $Path = "D:\Backup\*.v*"
	#		# Deletion task
	#		get-childitem $Path -recurse | where { $_.lastAccesstime -lt $RecentUse -and $_.CreationTime -lt $HowOld `
	#			-and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

		# Cleanup SQL Backup files
		#=====================
		# Example paths
		# G:\Backup
		# S:\Microsoft SQL Server\MSSQL13.MSSQLSERVER\MSSQL\Backup

	#	if ( Test-Path "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "S:\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup" )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "Z:\Program Files\Microsoft SQL Server\MSSQL*.MSSQLSERVER\MSSQL\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	#	if ( Test-Path "G:\Backup )
	#		{
	#		# Years older than #$HowOld = [DateTime]::Now.AddYears(-1)
	#		# If older than 14 days
	#		$HowOld= [DateTime]::Now.AddDays(-14)
	#		$RecentUse = [DateTime]::Now.AddDays(-14)
	#		# Path to root folder
	#		$Path = "G:\Backup\*.bak"
	#		# Deletion task
	#		get-childitem $Path -Recurse -Depth 1 -EA SilentlyContinue | where { $_.lastAccesstime -lt $RecentUse `
	#			-and $_.CreationTime -lt $HowOld -and $_.LastWriteTime -lt $RecentUse } | remove-item -force -verbose
	#		}

	# Check folder size after cleanup
	#==========================
	if ( $PSVersionTable.PSVersion.Major -gt 4 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse -Depth 1 -EA 4 | Measure-Object -Property Length -Sum ).sum
		}
	if ( $PSVersionTable.PSVersion.Major -lt 5 )
		{
		$AfterSize = (Get-ChildItem "$DeviceDriveLetter" -Recurse | Measure-Object -Property Length -Sum ).sum
		}

	$After = [math]::Round($AfterSize/1GB,2)
	}


	# Summary Report
	#==================================
	$ProfileTableOutput = $ProfileTableObject | sort -property SizeGB -desc | out-string
	$CFolderOutput = $Cfolders | sort -property SizeGB -desc | out-string
	$Computer = $ENV:ComputerName

	$CdriveCleanupReport = @()
 
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += $DSMessage
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "# Server Drive audit on server $($Computer)"
	$CdriveCleanupReport += "# Server Drive = $($DriveLetter)"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += "Before totals = $($Before) to after total = $($After)"
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "# Software Distribution folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $SoftwareDistribution | out-string
	$CdriveCleanupReport += ""

if ($Driveletter -eq "C" )
	{
	$CdriveCleanupReport += "# Audit of profiles for cleanup"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $ProfileTableOutput | out-string
	$CdriveCleanupReport += ""
	}

	$CdriveCleanupReport += "# Audit of folder size"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += $CFolderOutput | out-string
	$CdriveCleanupReport += ""
	$CdriveCleanupReport += "NOTE: Manual effort required:"
	$CdriveCleanupReport += "SME/SystemOwner/SysAdmin/Server SME required to clean up drive folders"
	$CdriveCleanupReport += "#===================================="
	$CdriveCleanupReport += ""
	}

# Verify output
$CdriveCleanupReport = $CdriveCleanupReport | out-string
$CdriveCleanupReport


#Check the value of $strCondition
IF ($strCondition -eq "Good")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"NO SME/SystemOwner/SysAdmin/Server action required")
	$bag.AddValue('Result',$strCondition)
	}
IF ($strCondition -eq "Bad")
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"$CdriveCleanupReport")
	$bag.AddValue('Result',$strCondition)
	$bag.AddValue('Summary',$CdriveCleanupReport)
	}

# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"WINOS Cleanup Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
		  </ScriptBody>
          <TimeoutSeconds>360</TimeoutSeconds>
        </WriteAction>
      </Recovery>
      <Recovery ID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor.Recovery" Accessibility="Public" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.Computer" Monitor="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor" ResetMonitor="true" ExecuteOnState="Warning" Remotable="true" Timeout="300">
        <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Windows!Microsoft.Windows.PowerShellWriteAction">
          <ScriptName>Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor.Recovery.v1059.ps1</ScriptName>
          <ScriptBody>
#=================================================================================
#  Proactive Group Policy System Event ID 1096 recovery
#
#  Author:  Kevin Justin
#  v1.0
#=================================================================================


# Manual Testing section - put stuff here for manually testing script - typically parameters:
#=================================================================================
# $ComputerName = "computername.domain.com"
$ComputerName = $env:ComputerName
#=================================================================================


# Constants section - modify stuff here:
#=================================================================================
# Assign script name variable for use in event logging.
$ScriptName = "Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor.Recovery.v1059.ps1"
$EventID = "680"
#=================================================================================


# Starting Script section - All scripts get this
#=================================================================================
# Gather the start time of the script
$StartTime = Get-Date
#Set variable to be used in logging events
$whoami = whoami
# Load MOMScript API
$momapi = New-Object -comObject MOM.ScriptAPI
# Load PropertyBag function 
$bag = $momapi.CreatePropertyBag()

#Log script event that we are starting task
$momapi.LogScriptEvent($ScriptName,$EventID,0,"Script is starting. `n Running as ($whoami).")
#=================================================================================


# Begin MAIN script section
#=================================================================================
# Date
$date = get-date -uFormat "%Y-%m-%d"

# Grab past hour
$Time = [DateTime](Get-Date).AddHours(-1)
$FourHours = [DateTime](Get-Date).AddHours(-4)

$momapi.LogScriptEvent($ScriptName,$EventID,0,"Gather Proactive Group Policy EventID 1096 report for date ($date).")

$DSMessage = "Proactive Group Policy EventID 1096 Alert report for date ($date)."

# Check for 1096 System Events
#===============================
$Failure = get-eventlog -logname System -after $FourHours | ? { ( $_.EventID -eq 1096 ) }

$Success = get-eventlog -logname System -after $StartTime | ? { ( $_.EventID -eq 1500 ) `
	-OR ( $_.EventID -eq 1501 ) -OR ( $_.EventID -eq 1502 ) -OR ( $_.EventID -eq 1503 ) `
	}


#=====================================
#Check the value of $strCondition
if ( $Failure.Count -gt 0 )
	{
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Running recovery to replace Registry.pol and gpupdate /force to resolve")

	# Check that Registry.pol larger than 0
	$BeforePolFile = (gci .\Registry.pol ).length

	# Recovery Script
	#================
	C:
	cd "C:\Windows\System32\GroupPolicy\Machine"
	copy .\Registry.pol .\Registry.bak
	remove-item .\Registry.pol

	# Run GPUpdate to see if server will grab group policy
	#=====================================================
	gpupdate /force

	if ( $BeforePolFile -gt 0 )
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Group Policy Registry.pol file zero size on server")
		}

	$AfterPolFile = (gci .\Registry.pol ).length

	if ( $AfterPolFile -eq 0 )
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"SME/SystemOwner/SysAdmin/Server action required to fix group policy file Registry.pol on server")
		}

	if ( $AfterPolFile -gt $BeforePolFile )
		{
		$momapi.LogScriptEvent($ScriptName,$EventID,0,"Group Policy Registry.pol file greater than zero on server")
		}
	
	$strCondition = "Good"
	#$momapi.LogScriptEvent($ScriptName,$EventID,0,"SME/SystemOwner/SysAdmin/Server action required to fix group policy file Registry.pol on server")
	$bag.AddValue('Result',$strCondition)
	}

if ( $Success.Count -gt 0 )
	{
	$strCondition = "Bad"
	$momapi.LogScriptEvent($ScriptName,$EventID,0,"Group Policy update completed, no failures")
	$bag.AddValue('Result',$strCondition)
	$bag.AddValue('Summary',"Group Policy update completed, no failures")
	}


# Return all bags
$bag
#=================================================================================
# End MAIN script section


# End of script section
#=================================================================================
#Log an event for script ending and total execution time.
$EndTime = Get-Date
$ScriptTime = ($EndTime - $StartTime).TotalSeconds
$momapi.LogScriptEvent($ScriptName,$EventID,0,"`n Script Completed. `n Script Runtime: ($ScriptTime) seconds.")
#=================================================================================
# End of script
		  </ScriptBody>
          <TimeoutSeconds>360</TimeoutSeconds>
        </WriteAction>
      </Recovery>
      <Recovery ID="Microsoft.Windows.Server.2016.Eventlog.Service.Recovery" Accessibility="Public" Enabled="true" Target="MWS6D!Microsoft.Windows.Server.10.0.OperatingSystem" Monitor="MWS6M!Microsoft.Windows.Server.10.0.OperatingSystem.EventLogServiceHealth" ResetMonitor="true" ExecuteOnState="Error" Remotable="true" Timeout="300">
         <Category>Custom</Category>
        <WriteAction ID="PSWA" TypeID="Microsoft.Windows.Server.2016.Eventlog.Service.WA">
          <TimeoutSeconds>300</TimeoutSeconds>
        </WriteAction>
      </Recovery>
    </Recoveries>
    <Overrides>
      <MonitorPropertyOverride ID="Override.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor" Context="MWS6D!Microsoft.Windows.Server.10.0.Computer" Enforced="false" Monitor="MWS6M!Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor" Property="Enabled">
        <Value>false</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Severity.Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth" Context="MWS6D!Microsoft.Windows.Server.10.0.LogicalDisk" Enforced="false" Monitor="MWS6M!Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth" Property="AlertSeverity">
        <Value>Warning</Value>
      </MonitorPropertyOverride>
      <MonitorPropertyOverride ID="Override.Severity.Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor" Context="Windows!Microsoft.Windows.OperatingSystem" Enforced="false" Monitor="MWS6M!Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor" Property="AlertSeverity">
        <Value>Warning</Value>
      </MonitorPropertyOverride>
    </Overrides>
  </Monitoring>
  <Presentation>
    <StringResources>
      <StringResource ID="Proactive.DailyTasks.WINOSAlerts.Report.Script.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.WINOSAlerts.Report.Script.Task.Rule.AlertMessage" />
      <StringResource ID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor.AlertMessage" />
      <StringResource ID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Secondary.Monitor.AlertMessage" />
      <StringResource ID="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.AlertMessage" />
      <StringResource ID="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.AlertMessage" />
      <StringResource ID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Script.Task.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor.AlertMessage" />
      <StringResource ID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Task.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.GroupPolicy.2016.Report.Script.Alert.Rule.AlertMessage" />
      <StringResource ID="Proactive.DailyTasks.Microsoft.Windows.2016.Eventlog.Full.Script.Alert.Rule.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.2016.Eventlog.Service.NotFound.Recovery.Rule.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.2016.Eventlog.Service.FoundRunning.Recovery.Rule.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.2016.Eventlog.Service.RecoveryFailed.Recovery.Rule.AlertMessage" />
      <StringResource ID="Microsoft.Windows.Server.2016.Eventlog.Service.TooManyRecoveryAttempts.Recovery.Rule.AlertMessage" />
    </StringResources>
  </Presentation>
  <LanguagePacks>
    <LanguagePack ID="ENU" IsDefault="false">
      <DisplayStrings>
        <DisplayString ElementID="Microsoft.Windows.Server.Operating.System.2016.Monitoring.Addendum">
          <Name>Microsoft Windows Server Operating System 2016+ Monitoring Addendum</Name>
          <Description>
v1.0.5.9  4 Jan 2024 Resolution State logic improvements for large environments
v1.0.5.8 27 Dec 2023 Updated whitespace and monitor/rule reset logic updates, Recovery WA like TopProcess
v1.0.5.7 16 Nov 2023 Commented logical disk workflows, correct powershell quote errors
v1.0.5.6 18 Jul 2023 Updated reports for Informational alert, EventLog is full rule/DS and alert 
v1.0.5.3 28 Jun 2023 Updated closure DS and WA for rule automation and comments
v1.0.5.2 24 Apr 2023 GP report DS missing a + for $Test, overrides for MaxConcurrentAPI
v1.0.5.0 30 Jan 2023 Added GroupPolicy report, alerts, cleanup report with Andrew's logic
v1.0.4.9 30 Jan 2023 Updated with EventLog rules/task/WA/Recovery
v1.0.4.8 23 Jan 2023 Updated disk cleanup, EventLog Service recovery, GPO1096 event to 5, NTFS, Storport severity to warning
v1.0.4.5  7 Dec 2022 Updated to include SQL Backup example
v1.0.4.0 10 Oct 2022 Updates for 1096 GPO monitor error
v1.0.3.9 30 Aug 2022 Updates for GPO System EventID 1096 monitor and recovery
v1.0.3.4  3 Aug 2022 Updates for Monitor Type, Logical Disk, GPO event 1096 w recovery
v1.0.3.0 19 Jul 2022 Updated for OS cleanup, Recoveries
v1.0.2.7  6 Apr 2022 Updated Event Description for alert parameter errors
v1.0.2.5 10 Mar 2022 Updated StorportMiniportDriverTimedout monitors
v1.0.2.3 22 Feb 2022 Updated Monitor patterns
v1.0.1.9 28 Jan 2022 Updated 153 StorPort event logic, alert message
v1.0.1.3 10 Sep 2021 Update with MatchCount for StorPort monitor
v1.0.0.0  6 Apr 2021 Created management pack for auto closure cleanup</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.WINOSAlerts.Close.Script.DataSource">
          <Name>Proactive DailyTasks WINOSAlerts report and auto-close DataSource</Name>
          <Description>This datasource generates WINOSAlerts report and auto-close DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.BaseEventProvider">
          <Name>Proactive Microsoft Windows BaseEventProvider DataSource</Name>
          <Description>This datasource updates base event provider with more options</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Monitor.Datasource">
          <Name>Proactive Microsoft Windows LogicalDisk Cleanup Monitor DataSource</Name>
          <Description>This datasource runs cleanup on logical disk</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.GroupPolicy.2016.Report.Script.DataSource">
          <Name>Proactive Microsoft Windows 2016 Group Policy Report DataSource</Name>
          <Description>This datasource builds a report of Group Policy 2016+ alerts</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.Microsoft.Windows.2016.Eventlog.Full.Script.DataSource">
          <Name>Proactive Microsoft Windows 2016 Event Log full DataSource</Name>
          <Description>This datasource sets event logs to retention, size, and overwrite properties</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.DailyTasks.WINOSAlerts.2016.Close.Script.Alert.WA">
          <Name>Proactive DailyTasks WINOSAlerts report and auto-close on-demand task</Name>
          <Description>This write-action task generates WINOSAlerts report and auto-close DataSource</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.2016.LogicalDisk.Cleanup.WA">
          <Name>Proactive Microsoft Windows LogicalDisk Cleanup manual on-demand task</Name>
          <Description>This write-action task cleans up LogicalDisks</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Eventlog.Service.WA">
          <Name>Proactive Microsoft Windows Server EventLog service WA</Name>
          <Description>This write-action task restarts EventLog service</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.WINOS.Repeated.Event.MonitorType">
          <Name>Proactive WINOS Repeated Event MonitorType</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.SingleEventLogTimer2StateMonitorType">
          <Name>Proactive Microsoft Windows Single Event log with Timer and Matchcount MonitorType</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Monitor.MonitorType">
          <Name>Proactive Microsoft Windows Logical Disk Cleanup MonitorType</Name>
        </DisplayString>

        <DisplayString ElementID="Proactive.DailyTasks.WINOSAlerts.Report.Script.Alert.Rule">
          <Name>Proactive DailyTasks WINOSAlerts Report Script Alert Rule</Name>
          <Description>Proactive Scheduled rule to kick off datasource at 0615 M-F</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.WINOSAlerts.Report.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks WINOSAlerts Report Script Alert Rule</Name>
          <Description>{1}

{2}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.WINOSAlerts.Report.Script.Task.Alert.Rule">
          <Name>Proactive DailyTasks WINOSAlerts task Report Manual Task Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.WINOSAlerts.Report.Script.Task.Rule.AlertMessage">
          <Name>Proactive DailyTasks WINOSAlerts Report Script Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Script.Task.Alert.Rule">
          <Name>Proactive Microsoft Windows LogicalDisk Cleanup manual task Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.Cleanup.Script.Task.Alert.Rule.AlertMessage">
          <Name>Proactive Microsoft Windows LogicalDisk Cleanup Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Task.Alert.Rule">
          <Name>Proactive Microsoft Windows Server GroupPolicy EventId 1096 Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Task.Alert.Rule.AlertMessage">
          <Name>Proactive Microsoft Windows Server GroupPolicy EventId 1096 Task Rule Alert</Name>
          <Description>{0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.GroupPolicy.2016.Report.Script.Alert.Rule">
          <Name>Proactive DailyTasks WINOSAlerts 2016 Report Script Alert Rule</Name>
          <Description>Proactive Scheduled rule to kick off datasource at 0511 (local) M-F</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.GroupPolicy.2016.Report.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks WINOSAlerts 2016 Report Script Alert Rule</Name>
          <Description>{1}

{2}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Eventlog.Service.NotFound.Recovery.Rule">
          <Name>Microsoft Windows Server 2016 Eventlog Service Recovery Failed - Service Not Found Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Eventlog.Service.NotFound.Recovery.Rule.AlertMessage">
          <Name>Microsoft Windows Server 2016 Eventlog Service Recovery Failed - Service Not Found</Name>
          <Description>Event Description: {0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Eventlog.Service.FoundRunning.Recovery.Rule">
          <Name>Microsoft Windows Server 2016 Eventlog Service Failed - Service Already Running Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Eventlog.Service.FoundRunning.Recovery.Rule.AlertMessage">
          <Name>Microsoft Windows Server 2016 Eventlog Service Recovery Failed - Service Already Running</Name>
          <Description>Event Description: {0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Eventlog.Service.RecoveryFailed.Recovery.Rule">
          <Name>Microsoft Windows Server 2016 Eventlog Service Recovery Failed - Service is not running Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Eventlog.Service.RecoveryFailed.Recovery.Rule.AlertMessage">
          <Name>Microsoft Windows Server 2016 Eventlog Service Recovery Failed - Service is not running</Name>
          <Description>Event Description: {0}</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Eventlog.Service.TooManyRecoveryAttempts.Recovery.Rule">
          <Name>Microsoft Windows Server 2016 Eventlog Service Recovery has attempted to recover the service too many times Rule</Name>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Eventlog.Service.TooManyRecoveryAttempts.Recovery.Rule.AlertMessage">
          <Name>Microsoft Windows Server 2016 Eventlog Service Recovery has attempted to recover the service too many times</Name>
          <Description>Event Description: {0}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.Microsoft.Windows.2016.Eventlog.Full.Script.Alert.Rule">
          <Name>Proactive DailyTasks Microsoft Windows 2016 EventLog Full Script Alert Rule</Name>
          <Description>Proactive Scheduled rule to kick off datasource at 0711 Sunday</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.DailyTasks.Microsoft.Windows.2016.Eventlog.Full.Script.Alert.Rule.AlertMessage">
          <Name>Proactive DailyTasks Microsoft Windows 2016 EventLog Full Script Alert Rule</Name>
          <Description>{1}

{2}</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.DailyTasks.WINOSAlerts.Report.Script.Task">
          <Name>Proactive DailyTasks WINOSAlerts Autoclose Report Script Task</Name>
          <Description>Proactive DailyTasks WINOSAlerts AutoClose task to kick off on-demand</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.Task">
          <Name>Proactive Microsoft Windows LogicalDisk C: Cleanup manual on-demand task</Name>
          <Description>Proactive Microsoft Windows LogicalDisk C: Cleanup manual on-demand task</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.Task">
          <Name>Proactive Microsoft Windows LogicalDisk D: Cleanup manual on-demand task</Name>
          <Description>Proactive Microsoft Windows LogicalDisk D: Cleanup manual on-demand task</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.2016.Eventlog.Service.Task">
          <Name>Proactive Microsoft Windows Server 2016+ EventLog service script restart task</Name>
          <Description>Proactive Microsoft Windows Server 2016+ restarts EventLog service</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor">
          <Name>Proactive Storport Miniport Driver Timed Out Monitor</Name>
          <Description>The monitor alerts when the Storport miniport driver times out a request</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor" SubElementID="EventRaised">
          <Name>Event Raised</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor" SubElementID="TimerEventRaised">
          <Name>Timer Event Raised</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor.AlertMessage">
          <Name>Proactive Windows Storport Miniport Driver has timed out a request</Name>
          <Description>The Windows Storport Miniport Driver has timed out a request on the server {0}
		  {1}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Secondary.Monitor">
          <Name>Proactive Storport Miniport Driver Timed Out Secondary Monitor for Disk3 or Disk 4</Name>
          <Description>The monitor alerts when the Storport miniport driver times out a request for Disk3 or Disk 4 secondary drives</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Secondary.Monitor" SubElementID="EventRaised">
          <Name>Event Raised</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Secondary.Monitor" SubElementID="TimerEventRaised">
          <Name>Timer Event Raised</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Secondary.Monitor.AlertMessage">
          <Name>Proactive Windows Storport Miniport Driver has timed out a request for Disk3 or Disk 4 - Secondary drives</Name>
          <Description>The Windows Storport Miniport Driver has timed out a request on the server {0}
		  {1}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor">
          <Name>Proactive Microsoft Windows LogicalDisk C: Cleanup Monitor</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor" SubElementID="GoodCondition">
          <Name>Good Condition</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor" SubElementID="BadCondition">
          <Name>Bad Condition</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.AlertMessage">
          <Name>Proactive Microsoft Windows LogicalDisk C: Cleanup Monitor</Name>
          <Description>Proactive Microsoft Windows LogicalDisk C: Cleanup Monitor
		  {1}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor">
          <Name>Proactive Microsoft Windows LogicalDisk D: Cleanup Monitor</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor" SubElementID="GoodCondition">
          <Name>Good Condition</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor" SubElementID="BadCondition">
          <Name>Bad Condition</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.AlertMessage">
          <Name>Proactive Microsoft Windows LogicalDisk D: Cleanup Monitor</Name>
          <Description>Proactive Microsoft Windows LogicalDisk D: Cleanup Monitor
		  {1}</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor">
          <Name>Proactive Microsoft Windows Server Group Policy EventId 1096 Monitor</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor" SubElementID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor.Timer">
          <Name>Success state for Monitor Group Policy System EventID 1096</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor" SubElementID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor.Repeated">
          <Name>Error state for Monitor Group Policy System EventID 1096</Name>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.Server.GroupPolicy.EventID.1096.Monitor.AlertMessage">
          <Name>Proactive Microsoft Windows Server Group Policy EventId 1096 Monitor</Name>
          <Description>Proactive Microsoft Windows Server Group Policy EventId 1096 Monitor

$Data/Context/Context/DataItem/EventDescription$

Count: $Data/Context/Count$
Time Window Start: $Data/Context/TimeWindowStart$
Time Window End: $Data/Context/TimeWindowEnd$</Description>
        </DisplayString>

        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.C.Cleanup.Monitor.Recovery">
          <Name>Proactive Microsoft Windows LogicalDisk C Cleanup Monitor Recovery</Name>
          <Description>Cleans up C drive for some common logged scenarios</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.D.Cleanup.Monitor.Recovery">
          <Name>Proactive Microsoft Windows LogicalDisk D Cleanup Monitor Recovery</Name>
          <Description>Cleans up D drive for some common logged scenarios</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.C2.Cleanup.Monitor.Recovery">
          <Name>Proactive Microsoft Windows LogicalDisk C Cleanup Monitor Error Recovery</Name>
          <Description>Cleans up C drive for some common logged scenarios</Description>
        </DisplayString>
        <DisplayString ElementID="Proactive.Microsoft.Windows.LogicalDisk.D2.Cleanup.Monitor.Recovery">
          <Name>Proactive Microsoft Windows LogicalDisk D Cleanup Monitor Error Recovery</Name>
          <Description>Cleans up D drive for some common logged scenarios</Description>
        </DisplayString>
        <DisplayString ElementID="Microsoft.Windows.Server.2016.Eventlog.Service.Recovery">
          <Name>Microsoft Windows Server 2016+ EventLog service Monitor Error Recovery</Name>
          <Description>Restarts EventLog service on server if stopped</Description>
        </DisplayString>

        <DisplayString ElementID="Override.Microsoft.Windows.Server.10.0.StorportMiniportDriver.Timedout.153.Monitor">
          <Name>Override Proactive Storport Miniport Driver Timed Out Monitor</Name>
        </DisplayString>
        <DisplayString ElementID="Override.Severity.Microsoft.Windows.Server.10.0.LogicalDisk.AvailabilityHealth">
          <Name>NotUsed</Name>
          <Description>19 Jan 2023 - KWJ - Changing to warning to fall under AD and Team reports</Description>
        </DisplayString>
        <DisplayString ElementID="Override.Severity.Microsoft.Windows.Server.10.0.MaxConcurrentAPI.Monitor">
          <Name>NotUsed</Name>
          <Description>24 Apr 2023 - KWJ - Editing alert from critical to warning</Description>
        </DisplayString>
      </DisplayStrings>
    </LanguagePack>
  </LanguagePacks>
</ManagementPack>